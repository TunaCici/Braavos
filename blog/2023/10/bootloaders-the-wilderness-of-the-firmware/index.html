<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Bootloaders &amp; The Wilderness of The Firmware | Tuna Cici (Blog)</title>
  <meta name="description" content="Enjoy Life!">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:url" content="https://tunacici.com/blog/2023/10/bootloaders-the-wilderness-of-the-firmware/">
  <meta property="og:site_name" content="Tuna Cici (Blog)">
  <meta property="og:title" content="Bootloaders &amp; The Wilderness of The Firmware">
  <meta property="og:description" content="Between “pressing the power button” on your device to actually start using it, there exists many pieces of software from different vendors that must execute &amp;amp; work together for a system to Gracefully Boot™.
Most modern devices are capable of booting in a few seconds &amp;amp; being fully ready to be used. There are even areas (safety-critical) where sub 1 second boot time is not only possible but required! These timings are fascinating when you learn how much “software switching” happens &amp;amp; the important role they each play.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-10-06T00:00:00+00:00">
    <meta property="article:tag" content="Bootloader">
    <meta property="article:tag" content="Firmware">
    <meta property="article:tag" content="Arm">
    <meta property="article:tag" content="X86">

  <meta name="twitter:card" content="summary"><meta name="twitter:title" content="Bootloaders &amp; The Wilderness of The Firmware">
<meta name="twitter:description" content="Between “pressing the power button” on your device to actually start using it, there exists many pieces of software from different vendors that must execute &amp; work together for a system to Gracefully Boot™.
Most modern devices are capable of booting in a few seconds &amp; being fully ready to be used. There are even areas (safety-critical) where sub 1 second boot time is not only possible but required! These timings are fascinating when you learn how much “software switching” happens &amp; the important role they each play.">

  
  
    
  
  
  <link rel="stylesheet" href="/blog/css/style-white.css">
  
   <link rel="stylesheet" href="/blog/css/custom.css"> 
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  <link rel="icon" type="image/png" href="/favicon.ico" />
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

  <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li>
          <a class="icon" href=" https://tunacici.com/blog/2023/04/gnu/linux-cli-shells-eli5-sh-bash-zsh-and-more/">
            <i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i>
          </a>
        </li>
        
        
        <li>
          <a class="icon" href="https://tunacici.com/blog/2023/11/first-stage-loaders-bios-uefi-iboot1-u-boot-spl/">
            <i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i>
          </a>
        </li>
        
        <li>
          <a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
            <i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i>
          </a>
        </li>
        <li>
          <a class="icon" href="#">
            <i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i>
          </a>
        </li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f">
      <i class="fab fa-facebook " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&text=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-twitter " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-linkedin " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&is_video=false&description=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-pinterest " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware&body=Check out this article: https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f">
      <i class="fas fa-envelope " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-get-pocket " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-reddit " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-stumbleupon " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-digg " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&name=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware&description=Between%20%e2%80%9cpressing%20the%20power%20button%e2%80%9d%20on%20your%20device%20to%20actually%20start%20using%20it%2c%20there%20exists%20many%20pieces%20of%20software%20from%20different%20vendors%20that%20must%20execute%20%26amp%3b%20work%20together%20for%20a%20system%20to%20Gracefully%20Boot%e2%84%a2.%0aMost%20modern%20devices%20are%20capable%20of%20booting%20in%20a%20few%20seconds%20%26amp%3b%20being%20fully%20ready%20to%20be%20used.%20There%20are%20even%20areas%20%28safety-critical%29%20where%20sub%201%20second%20boot%20time%20is%20not%20only%20possible%20but%20required%21%20These%20timings%20are%20fascinating%20when%20you%20learn%20how%20much%20%e2%80%9csoftware%20switching%e2%80%9d%20happens%20%26amp%3b%20the%20important%20role%20they%20each%20play.">
      <i class="fab fa-tumblr " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&t=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-hacker-news " aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>
    <div id="toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#detect--initialize-hardware">Detect &amp; Initialize Hardware</a></li>
    <li><a href="#load-a-program-into-memory">Load a Program Into Memory</a></li>
    <li><a href="#pass-control-to-the-loaded-program">Pass Control to The Loaded Program</a></li>
  </ul>

  <ul>
    <li><a href="#connection-with-bootloaders">Connection With Bootloaders</a></li>
  </ul>

  <ul>
    <li><a href="#cpu">CPU</a></li>
    <li><a href="#memory--device-discovery">Memory &amp; Device Discovery</a></li>
  </ul>

  <ul>
    <li><a href="#cpu-1">CPU</a></li>
    <li><a href="#memory">Memory</a></li>
  </ul>
</nav>
    </div>
  </span>
</div>

<div class="alert-warning">
	⭐️	
	<a href="https://github.com/TunaCici/NBBS">New project: Non-Blocking Buddy System - May 27, 2024</a>
	⭐️
</div>


  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
    
      <img src="header.png" class="hero" alt="Good Morning, Good Afternoon, Good Night" />
    

      <h1 class="posttitle" itemprop="name headline">
        Bootloaders &amp; The Wilderness of The Firmware
      </h1>
      <div class="meta">
        
        <div class="postdate">
          
          <time datetime="2023-10-06 00:00:00 &#43;0000 UTC" itemprop="datePublished">2023-10-06</time>
          
        </div>
        
        
        <div class="article-tag">
            <i class="fas fa-tag"></i>
            
            
            <a class="tag-link" href="/tags/bootloader/" rel="tag">bootloader</a>
            
             ,  
            <a class="tag-link" href="/tags/firmware/" rel="tag">firmware</a>
            
             ,  
            <a class="tag-link" href="/tags/arm/" rel="tag">arm</a>
            
             ,  
            <a class="tag-link" href="/tags/x86/" rel="tag">x86</a>
            
        </div>
        
      </div>
    </header>

  
    <div class="content" itemprop="articleBody">
      <p>Between “pressing the power button” on your device to actually start using it, there exists many pieces of software from different vendors that must execute &amp; work together for a system to Gracefully Boot™.</p>
<p>Most modern devices are capable of <a href="https://forums.macrumors.com/threads/how-long-does-it-take-to-boot-your-macbook-pro.2198565/">booting in a few seconds</a> &amp; being fully ready to be used. There are even areas (safety-critical) where <a href="https://elisa.tech/blog/2022/12/07/linux-in-aerospace/#:~:text=the%20system%20must%20be%20operational%20in%20only%20a%20few%20seconds%20or%20even%20less.">sub 1 second boot time</a> is not only possible but required! These timings are fascinating when you learn how much “software switching” happens &amp; the important role they each play.</p>
<p>The overall process I just described above is called a <strong>boot process</strong>. It’s a rather “big” topic that covers things like: Firmware, BIOS, [U]EFI, First-Stage &amp; Second-Stage Bootloaders, ACPI, Device Trees and a little bit of X86, ARM &amp; Hardware. But worry not! I’m here to explain all of these (and more) in a nicely formatted &amp; easily digestible way.</p>
<p><img src="all-of-the-above.png" alt=""></p>
<p>Bootloader-Related Terms &amp; Logos</p>
<p>If you are ready, grab something to drink for yourself because this is going to be a “long” one &gt;.&lt;</p>
<p><strong>Quick Note:</strong> Initially I intended this to be a one giant writing. However, it turned out to be a REALLy long one, so I divided it into 3 parts.</p>
<ol>
<li><a href="https://medium.com/@tunacici7/bootloaders-the-wilderness-of-the-firmware-5a9b13c1bffd">Bootloaders &amp; The Wilderness of The Firmware*</a> (this one)</li>
<li>First-Stage Loaders: BIOS, [U]EFI &amp; ARM Counterparts (coming soon)</li>
<li>Second-Stage Loaders: GRUB2, iBoot, BOOTMGR &amp; More (W.I.P.)</li>
</ol>
<blockquote>
<p><strong>WARNING:</strong> This is a beginner — intermediate level writing with relatively limited info on technical stuff like; how-to build or implement-in-C and is written with the sole purpose of education and bringing more people into the topic of bootloaders in the hopes of ‘nurturing’ their curiosity.</p>
</blockquote>
<h1 id="problem">Problem</h1>
<p>There are basically two types of memory/storage types: <a href="https://en.wikipedia.org/wiki/Volatile_memory">volatile</a> and <a href="https://en.wikipedia.org/wiki/Non-volatile_memory">non-volatile</a>. When a device is not running all the data &amp; software are stored in a non-volatile storage like eMMC, HDD, SSD, USB Flash Drive, CD-ROM and so on. In contrast, when a device is running [some of] that data &amp; software are now stored in a volatile storage like <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a> and <a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory">DRAM</a>.</p>
<p><img src="volatile-vs-non-volatile.png" alt=""></p>
<p>Volatile vs. Non-Volatile Memory — Table Source: diyanaha.wordpress.com</p>
<p>See the <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann architecture</a> for more information on the question “why?”.</p>
<p>As with anything in life, your device/CPU has no idea what to do when it’s first started. It can’t just load your operating system and applications because it doesn’t even know what/where your storage device is, let alone your specific “operating system”.</p>
<p>Your device is [almost] completely blind at this point. It somehow must recover itself from this situation and become fully-functional. This process is called <a href="https://en.wikipedia.org/wiki/Bootstrapping#Software_loading_and_execution">bootstrapping</a>: <em>for a computer to pulls itself up by it’s own bootstraps.</em></p>
<p>I assume you got the problem defined in your mind. Just in case you didn’t here’s the problem “we” are trying to solve &amp; explain:</p>
<p><strong>How does a computer starts itself when it doesn’t know what is what and where is where?</strong></p>
<blockquote>
<p>Btw, the question above is a little bit naive. There are way more questions that needs to be asked. Of course, I will answer most of them here, but I didn’t explicitly specified them for simplicity sakes &gt;.&lt;</p>
</blockquote>
<h1 id="warming-up">Warming Up</h1>
<p>Every software program out there has some form of requirements from its working environment. Let’s give some examples.</p>
<ul>
<li><strong>Python Script:</strong> Requires <code>python</code></li>
<li><strong>Java Program:</strong> Requires <code>jre</code></li>
<li><strong>Most C / C++ Programs:</strong> Requires <code>libc</code> or <code>libc++</code></li>
<li><strong>Most PC Games:</strong> Requires <code>DirectX</code></li>
</ul>
<blockquote>
<p>Of course there are WAY more things that a program can require, but it’s just a simplification.</p>
</blockquote>
<p><img src="software-env-requirements.png" alt="">
An AR/VR Game Made /w Unity Has Many Layers of “Requirements” — Source: unity.com</p>
<p>Now, the above examples are just some <em>high-level requirements</em>. What about things like <code>stdin</code>, <code>stdout</code>, <code>TCP/IP Stack</code>, <code>Software Exceptions</code>, <code>Stack Area</code> and <code>Heap Area</code>? Most program expect you to have these types of thing because they are so “base/trivial”. Luckily we have this amazing thing called <em>operating systems</em> that does these types of stuff for us;) But how do they come to existence anyway?</p>
<p>When you launch a software program, your operating system handles most of the “boring” stuff for you like (not in-order):</p>
<ul>
<li>Loading dynamic libraries (e.g. <code>libc</code>)</li>
<li>Loading it into memory</li>
<li>Parsing the executable (e.g. <code>ELF</code>, <code>PE</code>)</li>
<li>Setting up the Stack</li>
<li>So on…</li>
</ul>
<p>Low-level programs like <em>kernels</em> or <em>generic firmwares</em> are not so different in this area. They, too, need to be loaded into memory and have some sort of <em>stack</em> set-up for them. Unlike “normal” programs however, they have additional requirements like “I want to run on CPU Core #1” or “Interrupts must be disabled on all cores”.</p>
<p><img src="high-vs-low-level-app-req.png" alt=""></p>
<p>A [presumably incorrect] Comparison Between High Level Software &amp; Low Level Software — Source: developer.qualcomm.com</p>
<p>As you can see these are not your “normal” requirements. These are more “hardware-related &amp; environmental” requirements. Now comes the big question:</p>
<p><strong>Who can satisfy these environmental requirements for low-level programs like <em>kernel</em> and <em>firmware</em>?</strong></p>
<h1 id="introducing-bootloaders">Introducing.. Bootloaders!</h1>
<p>Software program(s) that the CPU executes to boot itself is called are <strong>bootloaders</strong>. Now the term “bootloader” is very broad and generic. It could be a small <a href="https://github.com/mit-pdos/xv6-public/blob/master/bootasm.S">assembly stub</a>, a <a href="https://en.wikipedia.org/wiki/BIOS">firmware</a> or a multi-purpose <a href="https://www.gnu.org/software/grub/">project</a> like GNU GRUB.</p>
<blockquote>
<p>You might know <strong>bootloaders</strong> as the program that you see on the screen before launching your favorite operating system.</p>
</blockquote>
<p>According to <a href="https://en.wikipedia.org/wiki/Bootloader#:~:text=a%20computer%20program%20that%20is%20responsible%20for%20booting%20a%20computer">Wikipedia</a>, a bootloader is: “<em>… a computer program that is responsible for booting a computer.</em>” And throughout this writing I’ll use this as the base definition.</p>
<p><img src="different-bootloaders-screen.png" alt=""></p>
<p>Two Different Bootloaders &amp; Their Interface (Left: GRUB - Right: BOOTMGR)</p>
<p>As seen from the above examples, there are many forms that a bootloader can take and be written. For a better understanding, let’s list some of the core responsibilities of a bootloader:</p>
<ul>
<li><strong>Detect &amp; Initialize Hardware</strong></li>
<li><strong>Load a Program Into Memory</strong></li>
<li><strong>Pass Control to The Loaded Program</strong></li>
</ul>
<blockquote>
<p>When I say “program” I mean stuff like, kernels, operating systems or other-bootloaders. However, since they are technically also programs, I’m going to call ANYTHING that a bootloaders loads a program.</p>
<p>In other words: <strong>program === kernel/OS/bootloader</strong> throughout this writing.</p>
</blockquote>
<p>Most modern bootloaders, of course, do more than what listed about (e.g. <a href="https://www.memtest86.com">Diagnostics</a>, <a href="https://www.gnu.org/software/grub/manual/grub/html_node/Command_002dline-and-menu-entry-commands.html">Basic CLI</a>, <a href="https://limine-bootloader.org/">Cool GUI</a>). However, for a program to be properly called “a bootloader” it MUST handle the above 3 tasks.</p>
<h2 id="detect--initialize-hardware">Detect &amp; Initialize Hardware</h2>
<p>First thing first; <em>CPU,</em> <em>memory</em> and <em>storage</em>. These are the hardware devices that a bootloader program MUST detect and properly initialize before trying to “load” a program into memory.</p>
<p><img src="cpu-memory-board.png" alt=""></p>
<p>Raspberry Pi 4 Board Hardware Overview — Source: seeedstudio.com</p>
<p>Naturally, this part is hardware-dependent. Meaning the bootloader must be designed, implemented and built for the target <a href="https://medium.com/@tunacici7/what-are-cpu-architectures-and-instruction-sets-384e0365b4b9">CPU ISA</a> (e.g. x86, ARM64, RISC-V). This requires different booting methods &amp; standards to be used, but more on this later.</p>
<p>After that, the memory must be set-up. Here we are faced with a new problem. Since a bootloader is still a “program”, it itself needs to be loaded into memory. But how? Isn’t the bootloader responsible for that? Hmm… this seems similar to the <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">well-known chicken or the egg problem</a>.</p>
<p>Obviously we need some another program for this. And guess what! It is also a type of “bootloader”. More specifically a “<strong>First-Stage Bootloader</strong>”. Again, more on this later;)</p>
<p><img src="storage-devices.png" alt=""></p>
<p>Different Kind of Non-Volatile Storage Devices</p>
<p>But now, what about storage devices? The target program is, as we know, is stored inside a non-volatile memory. In this case, a bootloader MUST implement the proper device drivers &amp; use them to detect &amp; read from storage devices like eMMC, HDD, SSD and USB Flash. For example, an <a href="https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface">AHCI</a> driver is <a href="https://github.com/search?q=repo%3Arhboot%2Fgrub2+ahci&amp;type=code">implemented</a> in a bootloader so that it can operate on <a href="https://en.wikipedia.org/wiki/SATA">SATA drives</a>.</p>
<blockquote>
<p>Additionally, a bootloader can also initialize stuff like a serial port, keyboard, RAM buffer, display etc. Although not necessary, but most <a href="https://limine-bootloader.org">modern bootloaders</a> do include them for a better UX &amp; accessibility.</p>
</blockquote>
<h2 id="load-a-program-into-memory">Load a Program Into Memory</h2>
<p>A bootloader should be able to detect different programs from different storage devices &amp; then launch them. And, optionally, provide some arguments to the target program. Now, the question is “How”?</p>
<p><img src="different-programs-detected-by-grub.png" alt=""></p>
<p>Different Programs Detected by GRUB — Source: ubuntubuzz.com</p>
<p><strong>First</strong>, a bootloader must identify the program it wants to load. This is generally done by scanning a storage device (or a <a href="https://support.microsoft.com/en-us/windows/all-about-ssd-hdd-and-storage-types-9c6c7c59-7d1c-4611-9ba9-676d53cc0ff1">drive</a>) for files that have a specific <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">Magic™ header</a>. A magic header is a sequence-of-bytes that is unique to a particular type of program.</p>
<p>A bootloader can’t (and shouldn’t) just launch any type of program. It needs to know that “Okay, this program ‘can’ and ‘wants to’ be loaded by me.” This idea is implemented using Magic™ headers as previously said.</p>
<blockquote>
<p>You can think of Magic™ headers as signatures for files. I don’t know why they are called ‘Magic’ :/ Personally tho, I find them really interesting and you should look them too when you have a chance.</p>
</blockquote>
<p><img src="magic-headers.png" alt=""></p>
<p>Magic Header Are Used For Almost Any File Out There, Above is The ELF [Magic] Header — Source: nathanotterness.com</p>
<p>These Magic™ headers have other important meanings apart from being useful for bootloaders when detecting programs. They tell others:</p>
<ul>
<li>I am a/n <!-- raw HTML omitted --> of file.</li>
<li>I acknowledge what my <!-- raw HTML omitted --> represents</li>
<li>I comply with the specifications of my <!-- raw HTML omitted --></li>
</ul>
<blockquote>
<p>It’s like an agreement between programs! (we’ve just discovered <a href="https://en.wikipedia.org/wiki/Software_standard">software standards &amp; specifications</a>)</p>
</blockquote>
<p>Here we are faced with a new topic: <strong>boot specifications</strong>. They are not real programs but rather “specifications” that defines what a/n <!-- raw HTML omitted --> of software program can expect and how it should behave. And we use Magic™ headers to tell that “I am <!-- raw HTML omitted --> of file and acknowledge everything in it.”</p>
<blockquote>
<p>Boot specifications can also be known as <strong>boot protocols</strong>.</p>
</blockquote>
<p>We have different boot specifications out there. Some are open-source and popular and some or custom-made &amp; proprietary. Here’s some of the most common ones:</p>
<ul>
<li><a href="https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html"><strong>Multiboot 1/2</strong></a>: GNU’s boot protocol. Mainly used by GRUB for Linux.</li>
<li><a href="https://github.com/limine-bootloader/limine/blob/v5.x-branch/PROTOCOL.md"><strong>Limine</strong></a>: Modern boot protocol. Mainly used by hobbyist OS devs.</li>
<li><a href="https://www.kernel.org/doc/html/v5.6/x86/boot.html"><strong>Linux</strong></a>: Linux’s own boot protocol. Used by SysLinux on x86 platform.</li>
<li><a href="https://www.scs.stanford.edu/nyu/04fa/lab/specsbbs101.pdf"><strong>BIOS</strong></a>: Basic Input and Output System for PCs. More on this later.</li>
<li><a href="https://uefi.org/specifications"><strong>[U]EFI</strong></a>: Unified Extensible Firmware Interface. More on this later.</li>
<li><a href="https://github.com/AsahiLinux/docs/wiki/SW%3AMachO-Boot-Protocol"><strong>MachO</strong>:</a> Apple’s own [boot] protocol. Used by iBoot on Apple devices.</li>
</ul>
<p><img src="bootloader-asking-which-os-to-load.png" alt=""></p>
<p>Windows BOOTMGR Asking Which OS to Load — Source: technewsinc.com</p>
<p><strong>Second</strong>, a bootloader selects which one of the discovered programs to be loaded &amp; launched. This step is either pre-configured via a config file so that the bootloader “knows” which one to boot from OR it “asks” the user via a CLI or even a GUI. Most of the time the former method is used.</p>
<p>Different bootloaders have different config files, syntaxes and interfaces. This is purely implementation defined and the design is up to the bootloader developer. However, you can be [as an user] sure to know that some form of <strong>boot configuration</strong> is possible (e.g. config file).</p>
<p><img src="grub-cfg.png" alt=""></p>
<p>GRUB Config File Found Under /boot/grub/grub. cfg — Source: linuxbabe.com</p>
<p><strong>Third</strong>, depending on the boot specification/protocol, a bootloader sets up the environment the program expects itself to be in when launched. This step is further explained in the &lt;TODO: FIRMWARE_HISTORY&gt; section.</p>
<p><strong>Fourth</strong>, the program finally gets “parsed” &amp; loaded into the memory. This process depends entirely on the program format (type). It could just be as “simple” as parsing an <code>[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)</code> file and then loading its sections into the memory. Or it could be a Linux <code>[bzImage](https://en.wikipedia.org/wiki/Vmlinux#bzImage)</code> with <code>[initrd](https://en.wikipedia.org/wiki/Initial_ramdisk)</code> that needs additional things like decompressing.</p>
<p><img src="loading-into-memory-elf.png" alt=""></p>
<p>Loading ELF File Into Memory (Both Physical &amp; Virtual Memory is Given) — Source: ourembeddeds.github.io</p>
<p>After the parsing, a bootloader basically copies the program from the storage drive (non-volatile) to the memory (volatile). Generally this is as simple as just mirroring the executable format into memory byte-by-byte. However, there are some edge-cases that needs handling. For example;</p>
<ul>
<li><strong>Memory conflicts</strong>: If the program’s desired load address conflicts with the bootloader’s memory or other occupied areas, the bootloader may need to perform <a href="https://stackoverflow.com/questions/1203108/why-do-boot-loaders-relocate-in-memory">relocation</a> to get out of the way.</li>
<li><strong>Platform constraints:</strong> Some platforms (especially x86) have additional constrains like the infamous <a href="https://www.win.tue.nl/~aeb/linux/kbd/A20.html">A20 Line</a> or a <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O">Memorry-Mapped IO.</a></li>
</ul>
<blockquote>
<p>Generally, a [well-written] program is aware of these edge-cases and is designed to handle them by itself.</p>
</blockquote>
<h2 id="pass-control-to-the-loaded-program">Pass Control to The Loaded Program</h2>
<p>A bootloader job ends just before the loaded program gets executed. At this point of time, the program is loaded into the memory and is now ready to be executed.</p>
<p><img src="bootloader-and-the-program-in-memory.png" alt=""></p>
<p>Bootloader And The Program In the Memory (Visualized) — Source: embetronicx.com</p>
<p>You might be asking, “What happens to the bootloader in the memory after it’s done? Does it get deleted?” The answer depends on the bootloader and its configuration. It might:</p>
<ul>
<li><strong>Stay in the memory:</strong> Sometimes speed is key. So, no purging occurs.</li>
<li><strong>Relocate to another place</strong>: Might want to keep it for later(?)</li>
<li><strong>“Deletes” itself from the memory</strong>: Purge everything!</li>
</ul>
<p>Again, this behavior is implementation defined and there is no “right” answer.</p>
<blockquote>
<p>If you are working on low-level stuff, I advise you to assume the “worst” which the bootloader “Stays in the memory” and handle that accordingly.</p>
</blockquote>
<p>Finally, the bootloader calls the <em>ENTRY</em> function defined by the program’s linker in build-time. From now on the flow of execution continues from the program and it is assumed to be in “total control” of everything! Sounds cool &amp; dangerous…</p>
<p><img src="assembly-stub-entry-program.png" alt=""></p>
<p>An Example Assembly Entry Stub — (The Entry Label is Defines as _start)</p>
<blockquote>
<p>Take a pause here if you’d like to. The upcoming sections are going to be relatively more technical &amp; practical stuff &gt;.&lt;</p>
</blockquote>
<h1 id="firmware-between-hard-and-soft">Firmware (Between Hard and Soft)</h1>
<p>So far we have defined <em>what</em> a bootloader is and seen some of its main objectives (and how it achieves them). It is now time to get a bit more technical and talk about stuff like x86/ARM boot process, BIOS, [U]EFI and firmwares in general.</p>
<p>In the world of “computing” we have:</p>
<ul>
<li>the <strong>hardware:</strong> physical IRL component that handles the actual computing (e.g. CPU, RAM) and</li>
<li>the <strong>software:</strong> tells what the hardware should do &amp; how to behave (e.g. OS, Drivers, Applications)</li>
</ul>
<p>The thing with software is that.. it’s just a too broad of a term. I mean look at the image below and compare each software to other. They’re all technically software, but is it “smart” to identify them as “a software” and call it a day?</p>
<p><img src="kinds-of-software.png" alt=""></p>
<p>Some [Unofficial] Types of Software, There Are ofc More ‘Than What’s Above — Source: finoit.com</p>
<p>Can we really compare a low-level device driver to a Web application? Sure, they are both software, but the “level-of-abstraction” they work on is VASTLY different. Also, the stakes are VERY different. If a low-level software fails, it can literally “<strong>cook</strong>” the hardware (imagine if your CPU cooler failed to work *R.I.P.*). On the other hand we have high-level software like Stardew Valley that we can “always” restart to without much risk. The worst we can lose here is the game progress we made. (it still sucks tho)</p>
<p>Clearly we need some sort of way to distinguish between different types of softwares… Oh, wait. I found it! What’s the state between <strong>hard</strong> and <strong>soft</strong>? I know: it’s <a href="https://dictionary.cambridge.org/us/dictionary/english/firm"><strong>firm</strong></a>. Then let’s call this new type of software a <strong>firm</strong>ware. <em>I’m such a genius and creative person(!)</em></p>
<p><img src="releationship-between-hw-fw-sw.png" alt=""></p>
<p>Simplified View Showing The Relationship a Firmware Has With HW &amp; SW — Source: inspirezone.tech</p>
<p>We are going to classify all really-low-level programs as “<strong>firmware</strong>” instead of “<strong>software</strong>”. Since they are not really a software like video games or web browsers. They deal directly with the hardware and provide some sort of functionalities for the higher level softwares like kernels or a drivers. And, unlike software, they are designed/targeted for very-specific purposes like dealing with the XHCI controller or an optical mouse.</p>
<p>According to <a href="https://en.wikipedia.org/wiki/Firmware#:~:text=class%20of%20computer%20software%20that%20provides%20the%20low%2Dlevel%20control%20for%20a%20device%27s%20specific%20hardware.">Wikipedia</a>, a firmware is: “<em>… class of</em> <a href="https://en.wikipedia.org/wiki/Computer_software"><em>computer software</em></a> <em>that provides the</em> <a href="https://en.wikipedia.org/wiki/High-_and_low-level"><em>low-level control</em></a> <em>for a device’s specific</em> <a href="https://en.wikipedia.org/wiki/Computer_hardware"><em>hardware</em></a>”.</p>
<p>In Laymen’s terms: a firmware is simply a software program that directly talks with the hardware for very specify purposes.</p>
<p>There are of course more differences between a software and a firmware. Instead of just typing them out, let’s see them in a picture (most important ones).</p>
<p><img src="software-vs-firmware.png" alt=""></p>
<p>Some Comparisons Between SW &amp; FW — Source: hardwarebee.com</p>
<h2 id="connection-with-bootloaders">Connection With Bootloaders</h2>
<p>Now, the above section begs the questions “<em>Should the bootloaders be considered as a firmware or a software?</em>” The answer is <strong>both</strong>. Let me explain.</p>
<p>We know that a bootloader can be in any form (e.g. assembly stub, full-on project). This means that it can be considered as a <strong>firmware</strong> if it deals with low-level control of any kind-of device. It can also be considered as a typical <strong>software</strong> by providing services like a GUI and a CLI.</p>
<p>This distinction between a “firmware-level bootloader” and “software-level bootloader” is kinda confusing. To clarify it, the people-of-software world created two categories for bootloaders.</p>
<ul>
<li><strong>First-Stage Bootloaders:</strong> Like BIOS on x86 platforms</li>
<li><strong>Second-Stage Bootloader:</strong> Like GRUB2 or iBoot.</li>
</ul>
<p><img src="first-stage-to-second-stage.png" alt=""></p>
<p>The Overly-Simplified Transitions Between Different Boot Stages</p>
<p>You can already have some idea as to what they are. But, you will have to hold on to that thought just a little bit more. I’ll explain them in the coming sections;)</p>
<blockquote>
<p>Bootloaders [obviously] needs to handle each platform differently. Espacially the First-Stage bootloaders. Below sections give information on x86 &amp; ARM on their boot process &amp; characteristics.</p>
</blockquote>
<h1 id="x86--boot-characteristics">x86 — Boot Characteristics</h1>
<p><img src="x86-boot-overview.png" alt=""></p>
<p>X86 [Simplified] Boot Overview</p>
<p>NOTE: This section is mainly referenced from <a href="http://intermezzos.github.io/book/first-edition/multiboot-headers.html">intermezzOS’s wiki page</a>.</p>
<p>One of the main “philosophies” behind x86 is for it to be as <strong>general</strong> <strong>purpose</strong> as possible. It maintained backwards compatibility throughout years. But this made the overall boot process on x86 platforms a <a href="https://news.ycombinator.com/item?id=30666914">mess</a>.</p>
<p>The x86 boot process is a whole pile of hacks held together with duck tape &amp; glue. Each x86 generation added a feature that meant new steps for the process; further complicating it. The <a href="https://www.win.tue.nl/~aeb/linux/kbd/A20.html">A20 Line</a> is a good example to this:(</p>
<blockquote>
<p><a href="http://intermezzos.github.io/book/first-edition/multiboot-headers.html#:~:text=when%20your%20fancy%20new%20computer%20starts%20up%2C%20it%20thinks%20it%E2%80%99s%20an%208086%20from%201976.">Here’s a fun fact</a>: “when your fancy new computer starts up, it thinks it’s an <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> from 1978. And then, through a succession of steps, we transition through more and more modern architectures until we end at the latest and greatest”</p>
</blockquote>
<h2 id="cpu">CPU</h2>
<p>At <strong>first</strong>, the CPU is on a state called “real mode”. This is the 16-bit mode that the original x86 chips used.</p>
<p>The <strong>second</strong> one is the 32-bit “protected mode”. This mode add new things on top of the 16-bit “real mode”. It is called protected because the real mode sort of lets you do whatever you want (e.g. including bad ideas). Protected mode enables certain kinds of protections such as when accessing the RAM.</p>
<p>The <strong>third &amp; final</strong> mode is the 64-bit “long mode”. Naturally we want programs (like the Kernel) to be running in this state.</p>
<p>More information on this topic can be found <a href="https://www.tortall.net/projects/yasm/manual/html/arch-x86-modes.html">tortall.net — Execution Modes and Extensions</a>.</p>
<p><img src="diff-x86-cpu-modes.png" alt=""></p>
<p>Most Important X86 CPU Modes — Author: Faheem Syed</p>
<blockquote>
<p>The above states are important to us as the bootloader needs to handle transitions between them before it can pass control to the program.</p>
</blockquote>
<h2 id="memory--device-discovery">Memory &amp; Device Discovery</h2>
<p>The overall system on an x86 platform is described using a <a href="https://en.wikipedia.org/wiki/Memory_map">memory map</a>. It is basically an array of information that specifies which areas of memory is used, reserved or free. The below picture is a good example showing a memory map.</p>
<p><img src="x86-memory-map.png" alt=""></p>
<p>Physical Memory Map As Seen &amp; Reported by BIOS — Source: rekall-forensic.com</p>
<p>Unlike ARM, x86 platforms are more “dynamic”. Meaning the devices (e.g. PCIe, USB, Ethernet) are not necessarily known to “exist” before the system boots up. This is where <strong>First-Stage</strong> bootloaders, like BIOS, comes in to play. They “detect/discover” the devices available on the system and then create a memory map.</p>
<blockquote>
<p>Keep this “memory map” in mind. They will be important when we talk about Device Trees in ARM.</p>
</blockquote>
<h1 id="arm--boot-characteristics">ARM — Boot Characteristics</h1>
<p><img src="arm-boot-overview.png" alt=""></p>
<p>ARM [Simplified] Boot Overview (*most*)</p>
<p>Unlike x86, ARM platforms are generally targeted for more “mobile” devices and therefore follow a <strong>specialist</strong> philosophy. Although, <a href="https://en.wikipedia.org/wiki/Apple_M1">Apple’s M SoCs</a> proving this to be false.</p>
<p>For this reason ARM platforms are more <strong>static</strong> in nature. Meaning all of the hardware is designed to be closely working together and once it’s manufactured, it can’t be easily upgraded. For example, on x86 systems you can switch out your RAM modules and/or add more SATA ports.</p>
<blockquote>
<p>Again, <a href="https://www.apple.com/mac-pro/">Apple’s new Mac Pro</a> is proving this to be false /w expendable PCIe ports.</p>
</blockquote>
<p>Due to being “<strong>static</strong>” in terms of hardware peripherals, ARM platforms doesn’t “care” about backwards compatibility as much as x86. And by this, the boot process becomes more clear &amp; straight-forward.</p>
<p><img src="raspberry-pi5-board.png" alt=""></p>
<p>Hardware Parts Are (closely) Tied on This Raspberry Pi 5 (Popular ARM Board)</p>
<p>Unfortunately for ARM, having a “<strong>specialist</strong> philosopshy” resulted in it being full of proprietary &amp; vendor-dependent software/firmware solutions. Yes, the overall boot process is simpler and more clear. But, the actual implementation of it is [most of the time] <a href="https://www.reddit.com/r/hardware/comments/ymh8uu/eli5_is_there_any_good_reason_why_arm_systems/">NOT STANDARD!</a> This is a rather big problem as we will see in <strong>First-Stage Loader</strong> section.</p>
<blockquote>
<p>Luckily, with recent <a href="https://developer.arm.com/Architectures/Unified%20Extensible%20Firmware%20Interface">[U]EFI</a> and <a href="https://developer.arm.com/documentation/den0044/g/?lang=en">Arm® Base Boot Requirements</a> we might see more standardization in the ARM world. Here’s hoping!</p>
</blockquote>
<h2 id="cpu-1">CPU</h2>
<p>ARM does not suffer from the same mess of 16-bit real mode and 32-bit protected mode state transitions. Instead we have <a href="https://developer.arm.com/documentation/102412/0103/Privilege-and-Exception-levels/Exception-levels">Exception Levels</a>. Depending on your ARM core, every instruction is run on the same X-bit mode. For <em>AArch32</em>, it’s 32-bit and for <em>AArch64</em> it’s 64-bit.</p>
<p><img src="arm-exception-levels.png" alt=""></p>
<p>ARM Exception Levels — Source: developer.arm.com</p>
<p>The bootloader’s main job here is less cluttered here (but vendor-specific solutions can interfene). Its main focus here is mostly working closely with exceptions levels. More info on them can be found on <a href="https://developer.arm.com/documentation/102412/0103/Privilege-and-Exception-levels/Exception-levels">developer.arm.com — Privilege and Exception levels</a>.</p>
<h2 id="memory">Memory</h2>
<p>The overall system on ARM platforms are generally represented using <a href="https://en.wikipedia.org/wiki/Devicetree">Device Trees</a>. They can be compared to memory maps on x86, as they are both used to describe the system hardware. Below is an example Device Tree Structure.</p>
<p><img src="arm-device-tree-structure.png" alt=""></p>
<p>An Example [Part of An] ARM Device Tree Structure (Represents a QEMU ARM Virt Machine)</p>
<p>On the implementation level, device trees look “similar” to JSON files. They represent the system in an hierarchical view. For example, there can be a parent CPU cluster (<a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA Node</a>) that has many core’s defined as its children.</p>
<p>Device Trees can be in two different file formats.</p>
<ul>
<li><strong>Device Tree Structure</strong> <code>(.dts)</code><strong>:</strong> Human-readable (similar to JSON)</li>
<li><strong>Device Tree Blob</strong><code>(.dtb)</code><strong>:</strong> Machine-readable (simple Binary Blob)</li>
</ul>
<p>A <code>.dts</code> file can be compiled into <code>.dtb</code> &amp; vice-versa. Check out my simple <a href="https://gist.github.com/TunaCici/03aaa31cab18d9c7720dfe1ae52d6db8">GitHub Gist</a> to see how it is done. Shameless plug… ;)</p>
<p>The bootloader’s main job here is to “read &amp; parse” the <code>.dtb</code> file and initalize the hardware accordingly. And pass it <em>as-is</em> to the loaded program.</p>
<p>Physically, the <code>.dtb</code> files are generally stored inside “ROM/Flash” on the board and/or, optionally, embedded inside the <strong>First-Stage loader</strong>.</p>
<h1 id="closing-words">Closing Words</h1>
<p>Before we jump to First-Stage loaders, let’s take a break. We just saw &amp; learned A LOT of new things. Just let your mind rest a bit and let it digest the information.</p>
<p>Bootloaders are not so simple programs as you can already see &amp; feel. They cover wide range of fields: hardware, firmware and software). You need to at least understand some parts of them to get a good idea on what bootloaders are AND what they do. Try to take a few days of break and come back to this writing later again. I’m sure you’ll understand everything a bit better!</p>
<p>Very soon I’ll publish the next part of this bootloader series, which is going to be called <strong>First-Stage Loaders: BIOS, [U]EFI &amp; ARM Counterparts</strong>. I’m doing some final editing &amp; preparations for the images &amp; diagrams.</p>
<p>If you have spotted some errors and/or think that what I said was wrong, please DO tell me! It would mean a lot to me. And lastly, thanks for the reading.</p>
<p>Enjoy Life ❤</p>

    </div>
	<div class="post-footer">
		<hr />

		<img src="/blog/signature.png" alt="signature" style="height: 55px;" />

		<p>Thanks for reading & Take care <span style="font-style: normal;"> ❤ </span></p>
		<p>
			Follow me on
			<a href="https://twitter.com/tunacicii">X (formerly Twitter)</a>,
      if you like my works that is >.&lt;
		</p>

	</div>
  </article>

  <hr />

  <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/memes/">Memes</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#detect--initialize-hardware">Detect &amp; Initialize Hardware</a></li>
    <li><a href="#load-a-program-into-memory">Load a Program Into Memory</a></li>
    <li><a href="#pass-control-to-the-loaded-program">Pass Control to The Loaded Program</a></li>
  </ul>

  <ul>
    <li><a href="#connection-with-bootloaders">Connection With Bootloaders</a></li>
  </ul>

  <ul>
    <li><a href="#cpu">CPU</a></li>
    <li><a href="#memory--device-discovery">Memory &amp; Device Discovery</a></li>
  </ul>

  <ul>
    <li><a href="#cpu-1">CPU</a></li>
    <li><a href="#memory">Memory</a></li>
  </ul>
</nav>
    </div>

    <div id="share-footer" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f">
      <i class="fab fa-facebook fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&text=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-twitter fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-linkedin fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&is_video=false&description=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-pinterest fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware&body=Check out this article: https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f">
      <i class="fas fa-envelope fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-reddit fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&title=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-digg fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&name=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware&description=Between%20%e2%80%9cpressing%20the%20power%20button%e2%80%9d%20on%20your%20device%20to%20actually%20start%20using%20it%2c%20there%20exists%20many%20pieces%20of%20software%20from%20different%20vendors%20that%20must%20execute%20%26amp%3b%20work%20together%20for%20a%20system%20to%20Gracefully%20Boot%e2%84%a2.%0aMost%20modern%20devices%20are%20capable%20of%20booting%20in%20a%20few%20seconds%20%26amp%3b%20being%20fully%20ready%20to%20be%20used.%20There%20are%20even%20areas%20%28safety-critical%29%20where%20sub%201%20second%20boot%20time%20is%20not%20only%20possible%20but%20required%21%20These%20timings%20are%20fascinating%20when%20you%20learn%20how%20much%20%e2%80%9csoftware%20switching%e2%80%9d%20happens%20%26amp%3b%20the%20important%20role%20they%20each%20play.">
      <i class="fab fa-tumblr fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2ftunacici.com%2fblog%2f2023%2f10%2fbootloaders-the-wilderness-of-the-firmware%2f&t=Bootloaders%20%26%20The%20Wilderness%20of%20The%20Firmware">
      <i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>

    <div id="actions-footer">
      
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;">
          <i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;">
          <i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;">
          <i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
          <i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>


  <footer id="footer">
  <div class="footer-left">
    Pasteleft &#9752; 2024  Tuna Cici (Blog) 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/blog/lib/font-awesome/css/all.min.css>
<script src=/blog/lib/jquery/jquery.min.js></script>
<script src=/blog/js/main.js></script>



</html>
