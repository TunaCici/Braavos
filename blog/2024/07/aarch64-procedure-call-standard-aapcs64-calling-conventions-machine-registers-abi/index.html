<!DOCTYPE html>
<html lang="en-us">
<head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> AArch64 Procedure Call Standard (AAPCS64): Calling Conventions, Machine Registers &amp; ABI | Tuna Cici (Blog)</title>
  <meta name="description" content="Enjoy Life!">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:url" content="http://localhost:1313/blog/2024/07/aarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi/">
  <meta property="og:site_name" content="Tuna Cici (Blog)">
  <meta property="og:title" content="AArch64 Procedure Call Standard (AAPCS64): Calling Conventions, Machine Registers &amp; ABI">
  <meta property="og:description" content="insert header here
Programming using high-level languages makes a ton of stuff trivial. Your compiler/interpreter abstracts a lot of stuff from you so that you can focus on what&amp;rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.
Calling function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&amp;rsquo;s meant to do (or not).">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-14T00:00:00+00:00">
    <meta property="article:tag" content="Aarch64">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Assembly">
    <meta property="article:tag" content="Eli5">

  <meta name="twitter:card" content="summary"><meta name="twitter:title" content="AArch64 Procedure Call Standard (AAPCS64): Calling Conventions, Machine Registers &amp; ABI">
<meta name="twitter:description" content="insert header here
Programming using high-level languages makes a ton of stuff trivial. Your compiler/interpreter abstracts a lot of stuff from you so that you can focus on what&rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.
Calling function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&rsquo;s meant to do (or not).">

  
  
    
  
  
  <link rel="stylesheet" href="/blog/css/style-white.css">
  
   <link rel="stylesheet" href="/blog/css/custom.css"> 
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  <link rel="icon" type="image/png" href="/favicon.ico" />
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

  <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li>
          <a class="icon" href=" http://localhost:1313/blog/2023/11/first-stage-loaders-bios-uefi-iboot1-u-boot-spl/">
            <i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i>
          </a>
        </li>
        
        
        <li>
          <a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
            <i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i>
          </a>
        </li>
        <li>
          <a class="icon" href="#">
            <i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i>
          </a>
        </li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f">
      <i class="fab fa-facebook " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&text=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-twitter " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-linkedin " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&is_video=false&description=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-pinterest " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI&body=Check out this article: http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f">
      <i class="fas fa-envelope " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-get-pocket " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-reddit " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-stumbleupon " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-digg " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&name=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI&description=insert%20header%20here%0aProgramming%20using%20high-level%20languages%20makes%20a%20ton%20of%20stuff%20trivial.%20Your%20compiler%2finterpreter%20abstracts%20a%20lot%20of%20stuff%20from%20you%20so%20that%20you%20can%20focus%20on%20what%26rsquo%3bs%20important%3a%20getting%20shit%20done%2c%20efficiently.%20One%20of%20those%20abstractions%20is%20functions.%0aCalling%20function%20is%20one%20of%20the%20first%20things%20you%20learn%20when%20starting%20programming.%20They%20are%20relatively%20trivial%3a%20you%20just%20type%20the%20function%20name%2c%20pass%20some%20parameters%20and%20then%20it%20does%20what%20it%26rsquo%3bs%20meant%20to%20do%20%28or%20not%29.">
      <i class="fab fa-tumblr " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&t=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-hacker-news " aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>
    <div id="toc">
      <nav id="TableOfContents"></nav>
    </div>
  </span>
</div>

<div class="alert-warning">
	⭐️	
	<a href="https://github.com/TunaCici/NBBS">New project: Non-Blocking Buddy System - May 27, 2024</a>
	⭐️
</div>


  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
    
      <img src="header.png" class="hero" alt="TODO" />
    

      <h1 class="posttitle" itemprop="name headline">
        AArch64 Procedure Call Standard (AAPCS64): Calling Conventions, Machine Registers &amp; ABI
      </h1>
      <div class="meta">
        
        <div class="postdate">
          
          <time datetime="2024-07-14 00:00:00 &#43;0000 UTC" itemprop="datePublished">2024-07-14</time>
          
        </div>
        
        
        <div class="article-tag">
            <i class="fas fa-tag"></i>
            
            
            <a class="tag-link" href="/tags/aarch64/" rel="tag">aarch64</a>
            
             ,  
            <a class="tag-link" href="/tags/c/" rel="tag">c</a>
            
             ,  
            <a class="tag-link" href="/tags/assembly/" rel="tag">assembly</a>
            
             ,  
            <a class="tag-link" href="/tags/eli5/" rel="tag">eli5</a>
            
        </div>
        
      </div>
    </header>

  
    <div class="content" itemprop="articleBody">
      <p>insert header here</p>
<p>Programming using high-level languages makes a ton of stuff trivial. Your compiler/interpreter abstracts a lot of stuff from you so that you can focus on what&rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.</p>
<p>Calling function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&rsquo;s meant to do (or not). You don&rsquo;t need to think about whether the underlying CPU architecture is 64-bit or that it&rsquo;s by AMD, Intel or Apple. All you care is that the function gets called and successfully returns. That is until you need to do some micro optimizations, debugging on registers or any system-level programming.</p>
<p>insert basic C function call here</p>
<p>At that point it is good to know how the compiler, the standard library and the kernel/OS handles functions. For example, you might need to consider how stack is managed, how are functions called to &amp; returned from, how parameters are passed (via registers or stack). They all depend on your specific platform (e.g., AMD64, AArch64) and the kernel/OS (e.g., Linux, macOS).</p>
<p>Here, I will try to ELI5 those concepts and abstraction for the AArch64 platforms. However, the idea is basically the same for any other. Throught this writing, I will assume that you are familiar with stuff like compilers, linkers, ELF format, ISA and basic assembly code. Feel free to stop reading at any point and gain more insight on those topics as they will help broaden your knowledge on system-level programming &amp; computer hardware;)</p>
<h1 id="calling-conventions">Calling Conventions</h1>
<p>Everyone writes programs and codes in their own way. The compiler they choose to use can also be different; so does the hardware they worked on; or even the programming language itself. All these (not limited to) factors can affect the final machine code of the program.</p>
<p>insert different compilers /w same code producing diff machine code here</p>
<p>Naturally, we expect our program to behave the same with the same [high-level] code; doesn&rsquo;t matter the compiler or the underlying hardware. If I wrote a static/dynamic library for others to use (e.g., libssl, libcurl) I expect it to work for the platform I compiled it to, whether AMD64 or AArch64. The kernel/OS version, CPU generation (e.g. Apple M1 vs M4) or the compiler version should NOT matter. How is this achieved?</p>
<p>I mean really think about it: How does a program/library you download from the internet works on your machine? The CPU you have might not have been around when the program was first compiled!</p>
<p>A function can be defined as a block of code with a well-defined interface and behavior that can be called multiple times. The program/code that calls the function is called caller, and the function itself is called callee. The interface of a function is where we will be focusing on.</p>
<p>On higher-level languages the interface of a function is sometimes called an API (Application Programming Interface). Programmers must know this interface to make a function call. The order of the parameters, and their type matters for languages like C, Rust, Java. However, languages like Python and Ruby support named parameters, where the order doesn&rsquo;t &ldquo;really matter&rdquo;.</p>
<p>insert API example here</p>
<p>APIs are higher-level interfaces that is used on higher-level languages. They have language-specific parameters and types. So, they are generally intended to be used for the language they are written in. But in the end they are all compiled into machine code and programs talk with each other with that language; not C or Swift.</p>
<p>We have seen that even if the language might be the same, the compiled machine code can be different. And if the machine code is different: how would the APIs work? Below is an example function that&rsquo;s compiled using two different compilers /w different machine code. Yet, they work. How?</p>
<p>insert a C function and a program compiled with different compilers here</p>
<p>Notice how even the machine code is generally different, some stuff is the same. Especially the begging and the end. And it&rsquo;s not just mere coincidence. The code you see there is called ABI (Application Binary Interface). They define how functions (or subroutines) should be called and returned from at the machine code level. You can compare them to APIs; the idea is the same, but the language/level they work on is different.</p>
<p>insert basic API vs ABI here</p>
<p>Just like how the design of an API is unique to the author of the software, the design of an ABI is also unique to the it&rsquo;s platform. There are many design factors that defines an ABI (e.g., calling conventions, data type &amp; alignment). The one we will focus on is Procedure Call Standard (PCS) for AArch64 platforms. Also known as - calling convention for AArch64.</p>
<blockquote>
<p>I won&rsquo;t be explaining the data types &amp; alignment as to keep the writing on topic: calling conventions. They deserve their own writing, which I might do on another time;)</p>
</blockquote>
<p>insert different standards and machine abstractions here</p>
<p>A Calling Convention is a scheme that defines how functions receive their parameters and return their results. They specify how a program should handle functions at the machine code level. Below are some of the schemes that they define (not limited to):</p>
<ul>
<li>How parameters are passed &amp; returned</li>
<li>Which registers the callee must preserve</li>
<li>How the stack should be managed between the callee and caller</li>
</ul>
<blockquote>
<p>From now on I will use the ABI and calling convention interchangeably to keep things on ELI5 level. But know that they are NOT the same time. Calling conventions are just a subset of ABI design.</p>
</blockquote>
<p>Each platform has their own conventions, but the sane ones usually share a lot of similarities. Below are the preferred calling conventions for each widely used platforms.</p>
<ul>
<li>AMD64 (x86_64): Sytem V ABI</li>
<li>AArch64 (ARM64): Procedure Call Standard for AArch64</li>
<li>RISC-V: RISC-V Calling Convention</li>
<li>PowerPC: System V ABI for PowerPC</li>
</ul>
<p>The one we are focusing on is AArch64. But before we move on to that, let&rsquo;s talk about registers and stack as they are the blocks which a calling convention is build upon.</p>
<h1 id="machine-registers">Machine Registers</h1>
<p>There are many registers defined in AArch64 and the availability of them depends on the architecture version (e.g., ARMv8 vs. ARMv9) and the platform vendor. However, all of them are at least expected to implement the basic register banks: general-purpose and (optionally) SIMD. We will focus on general-purpose registers and what their purposes.</p>
<p>insert AArch64 general-purpose related image here</p>
<p>AArch64 provides 31 general-purpose registers, each 64 bits wide. They are named X0 … X30. Although the general-purpose registers are equal and interchangeable at the architecture level, in practice their purpose is defined by the AAPCS64 and most sane compilers/programmers adhere to it.</p>
<blockquote>
<p>The following sections are taken from Maria Azeria Markstedter&rsquo;s ARM Assembly: Internals &amp; Reverse Engineering Book. Shout out to her for the great book!</p>
</blockquote>
<h1 id="x0-x7">X0-X7</h1>
<p>These registers are used for argument registers to pass parameters and return a result. More on this later.</p>
<h1 id="x8">X8</h1>
<p>Pointer to where to write the return value if &gt;128 bits, otherwise scratch register. It can be used to pass the address location of an indirect result.</p>
<h1 id="x915">X9–15</h1>
<p>These are caller-saved temporary registers used to preserve values across a call to another function. The affected registers are saved in the stack frame of the caller function, allowing the callee function to modify these registers.</p>
<h1 id="x16-x17">X16-X17</h1>
<p>These are intraprocedure-call temporary registers that can be used as temporary registers for immediate values between function calls. They can be used for ordinary computations within any given function. However, AAPCS64 gives them a different purpose.</p>
<p>For example, if a program calls a function defined in a shared library such as malloc(), this function call may be implemented via a call through the procedure linkage table (PLT) to call the malloc() implementation inside another module.</p>
<p>The PLT stub responsible for find and transferring execution to the malloc() function in the other library can use the X16 and X17 registers as intraprocedural call registers freely, without having to take care not to corrupt their values. LLVM, for example, will compile PLT stubs that make use of X16 and X17. </p>
<blockquote>
<p>Also see GCC&rsquo;s veneer for more examples on X16 and X17 usage.</p>
</blockquote>
<p>insert X16 and X17 example usage here</p>
<h1 id="x18-platform-register">X18 (Platform Register)</h1>
<p>The X18 platform is a general-purpose register like any. The AAPCS, however, reserves it to be the platform register, pointing to some platform-specific data. More on this later.</p>
<h1 id="x19-x28">X19-X28</h1>
<p>These are callee-saved registers that are saved in the stack frame of the called function, allowing the function to modify these registers but also requiring it to restore them before returning to the caller.</p>
<h1 id="x29-fp">X29 (FP)</h1>
<p>It is used as a frame pointer (FP) to keep track of the stack frame. More on this later.</p>
<h1 id="x30-lr">X30 (LR)</h1>
<p>It is the link register (LR) holding the return address of the function. More on this later.</p>
<p>insert table of general-purpose registers here</p>
<h1 id="simd-and-floating-point-registers">SIMD and Floating-Point Registers</h1>
<p>In addition to the 64-bit general-purpose registers, AArch64 also supplies a series of 32 x 128-bit vector registers for use in optimized single instruction multiple data (SIMD) operations for performing floating-point arithmetic. These registers are each 128-bits long and named V0 … V31.</p>
<p>Similar to general-purpose registers, V0 … V7 the  first eight SIMD registers are used for argument registers to pass parameters and return a result. The rest is either used as scratch registers. However, there are some calling convention details. More on this later.</p>
<p>insert SIMD registers for AArch64 here</p>
<h1 id="aapcs64">AAPCS64</h1>
<p>Most platform&rsquo;s author/owner describes their calling conventions for public use. After all that&rsquo;s what they are meant for: for everyone to use and adapt. We are currently only interested in Arm&rsquo;s.</p>
<p>Arm® Architecture describes their calling conventions on their GitHub page named Procedure Call Standard for the Arm® 64-bit Architecture (AArch64). We will shortly call it: AAPCS64. </p>
<p>There are other documents on that Arm&rsquo;s GitHub page that further describes their ABI. Check them out if you are curious!</p>
<p>insert Arm ABI documents and their purpose for 64-bit here</p>
<p>Inside the AAPCS64 there are multiple sections and each deserve their own writings. We are only going to talk about calling conventions, but for the curious: here&rsquo;s other sections that&rsquo;s described in it:</p>
<ul>
<li>Data Type and Alignment</li>
<li>The Base Procedure Call Standard</li>
<li>Standard Variations</li>
<li>C and C++ Language Mappings</li>
</ul>
<p>AAPCS64 is kind of a long and it would be pointless to explain everything in it. I will only talk about the parts that I consider to be the most useful when doing casual programming for AArch64 platforms.</p>
<h1 id="parameter-passing">Parameter Passing</h1>
<p>Naturally, [on any language] when calling a function the caller and the callee must agree on how the parameters must be passed around on machine level. AAPCS64 defines this in Section 6. The Base Procedure Call Standard. It describes that:</p>
<ul>
<li>X0 … X7: Should be used for the first eight (8) parameters</li>
<li>Stack: Should be used for any additional parameters</li>
</ul>
<p>I think it is pretty straightforward. We can even see this in action. Let&rsquo;s look at an example C function with 4, 8 and 12 parameters.</p>
<p>insert C function with 4, 8 and 12 parameters and it&rsquo;s machine code here</p>
<p>As you can see the first (1st) parameter is stored in X0, second (2nd) in X1, third (3rd) in X2 and so on… After the eight (8th) the additional parameters are stored in thread stack. This is where things get interesting.</p>
<p>Stating the obvious: CPU registers are fast and stack memory is slow. We want to stay away from accessing the memory as much as possible. Generally, compilers are pretty good at optimizing on this and you won&rsquo;t have to worry about the amount of parameter a function takes.</p>
<p>Sometime, however, you might need those extra nano/microseconds (e.g., low-latency systems).</p>
<h1 id="result-return">Result Return</h1>
<p>This one, again, is pretty straightforward and clear. AAPCS64 states that the function return value should be stored in:</p>
<ul>
<li>X0 </li>
</ul>
<p>You can see from the below C function that the uint64_t return value is stored in X0 before the call to RET (function return).</p>
<p>insert C functions that returns the value in X0 here</p>
<blockquote>
<p>Personal note: I always wondered why C/C++ functions always returned one (1) value. What if I want to return two values like 2D coordinates of {x, y}? Well, now I know: the ABI just doesn&rsquo;t support it. Probably for good reasons.</p>
</blockquote>
<blockquote>
<p>Obviously, I learned about objects/structs and then used them to &ldquo;return more than one (1) value&rdquo;. But still, at the machine code level, a function still returns one (1) value: reference/pointer of an object.</p>
</blockquote>
<h1 id="the-stack">The Stack</h1>
<p>Almost all modern languages use the concept of stack. They are used for various reasons. I would like to give examples but am no language designer;( One thing I know is that they are used when calling functions.</p>
<p>The next parts assume that any language is designed to make use of the stack. There are, however, languages that DON&rsquo;T have stack. See Parrot or other functional languages.</p>
<p>Each thread in a program has its own stack. According to AAPCS64, a stack is a continuous memory region that the thread can use for storage of local variables and for passing additional arguments [if the first eight (8) register are insufficient].</p>
<p>insert stack representation in a C program here</p>
<p>The concept of stack is a pretty big topic and [again] deserves it&rsquo;s own writing. From now on I will assume that you have some familiarity with the thread stack in C.</p>
<p>In AAPCS64, a stack is defined to have the following three (3) values:</p>
<ul>
<li>Base: base of the stack (e.g., 0x800)</li>
<li>Limit: limit of the stack (e.g., 0x400)</li>
<li>Current Extent: current tack pointer (SP) (e.g., 0x600)</li>
</ul>
<p>The SP is basically a pointer that moves from base to limit as the stack grows. And from limit to base as the stack shrinks. Below is a visualization on this concept.</p>
<p>insert basic AAPCS64 stack visualization here</p>
<p>AAPCS64 further defines the stack to be full-descending. Now, there are four (4) different stack organizations. I am not going to explain them here as there is a great note about them by John Winans. I highly recommend you to read at is it&rsquo;s very informative and pretty short. It shouldn&rsquo;t take more than 15 minutes to understand it.</p>
<p>insert full-descending stack visualization here</p>
<p>Last, but not least, the AAPCS64 uses the stack to passing parameters. If there are more than eight (8) parameters, that is the X0 … X7 is already used, then the rest is put in stack. Below is an example C function and it&rsquo;s machine code that shows how stack is used to pass parameters.</p>
<p>insert C function that uses stack to pass parameters here</p>
<h1 id="machine-registers-1">Machine Registers</h1>
<p>Like we have seen before, Arm 64-bit architecture defines two mandatory register banks: general-purpose and SIMD. Technically, you can use them however you want, but in practice each have their own purposes defines by AAPCS64.</p>
<p>Let&rsquo;s talk about each of those registers.</p>
<p>X0 … X7: These register are used to pass the first eight (8) parameters into a function. The caller fills these register and then the callee function can use them however it sees fit. </p>
<p>Before the function returns, the X0 must be updated by the callee to store the function return value. However, if the return type is void or not used, compilers can optimize this away.</p>
<p>insert optimized X0 return value register here</p>
<p>X8: Also known as indirect result register. Frankly, I don&rsquo;t think the usage of this is not very well defined. AAPCS64 states that &ldquo;This is used to pass the address location of an indirect result, for example, where a function returns a large structure.&rdquo; From what I gather around the internet, each OS (e.g., Windows) and language (e.g., C++) uses it a bit differently.</p>
<p>Basically, if an object is too big to fit into a 64-bit register (or divided into multiple ones) the caller reserves a memory region (via stack or heap) and then passes a pointer/reference to it inside the X8 register. After that, the callee is able to access to that [big] object. Below is a basic example on this.</p>
<p>insert big ahh C structure that&rsquo;s passed onto a function here</p>
<p>X9 … X15: These are just scratch registers. Meaning a function can use them freely as temporary storages for intermediate calculations or data. AAPCS64, however, gives them a purpose and a name: caller-saved registers.</p>
<p>These register should be used by a function for values that are NOT needed after the next function call (if exists). Now, when I first saw this it seemed so vague. Like, okay… How do I know which values are needed and which are not? Why can&rsquo;t I just use them normally?</p>
<p>insert highlighted caller-saved registers in CPU here</p>
<p>For that I needed an example. I couldn&rsquo;t find a good one. But I did find one explanation that made it all make sense. You can read it If you want, but if you can wait a little bit, I prepared an example after this section that will help you understand on why they exists and why you shouldn&rsquo;t just use them normally.</p>
<p>X16 - X17: Ah the twin registers, also known as IP0 and IP1. They are the intra-procedure-call temporary registers. Like others, they can be as scratch registers, but AAPCS64 marks them as &ldquo;corruptible by function&rdquo;. Meaning, after ANY function call, the caller assumes them to be corrupt and act accordingly.</p>
<p>insert arm BL instruction here</p>
<p>In practice, however, they are used by veneers and other similar pieces of code. In Arm A64 ISA, the BL branch line instruction can only in the range of PC +/-128MiB. Most of the time your code won&rsquo;t have to jump around that much, but sometimes it happens (e.g., dynamic libraries OR switching from lower-address to higher-address range in kernel syscalls). To overcome this range limitation, compilers (like GCC) uses a small piece of code called veneers. I don&rsquo;t really looked at how they work, but know that they used to jump between codes that are FURTHER away from each other in [virtual] memory. Hence the IP0 and IP1 are called the intra-procedure-call registers.</p>
<p>insert veneer code generated by GCC here</p>
<p>X18: It&rsquo;s called the platform register. Like the name suggests, each platform (e.g., Linux, Windows, macOS) can define whatever use for it they want. The exact usage of it can also change from platform version to version.</p>
<ul>
<li>Apple (macOS, iOS, iPadOS…): Reserved</li>
<li>Linux: Task Structure pointer in kernel mode; (?) in user mode</li>
<li>Windows: Thread Environment Block pointer in user mode; reserved in kernel mode</li>
</ul>
<p>insert Apple XNU code block that reserves the x18 register here</p>
<p>As you can see, it isn&rsquo;t much used or have a well-defined usage on some common platforms. It&rsquo;s recommended (at least for now) just avoid using it.</p>
<p>X19 .. X28: Just like the previous scratch registers (caller-saved ones), these registers are also scratch registers. Similarly, AAPCS64 gives them their own purpose and name: callee-saved registers.</p>
<p>These register should be by the function if they ARE needed to be preserved after the call. The callee is the one responsible of saving AND restoring them.</p>
<p>insert highlighted callee-saved register in CPU here</p>
<p>Just like the caller-saved registers, the explanation by Arm and AAPCS64 seems confusing. In the coming section I will give a concrete example that will help you understand what it&rsquo;s meant by callee &amp; caller saved registers.</p>
<p>X29: This is the register that holds the frame pointer as describe by AAPCS64. A frame pointer is.. well a pointer that is used to keep track of the stack frame. When a new stack frame is created (after a function call) the base address of it is stored inside this register.</p>
<p>insert frame pointer diagram and relation to stack here</p>
<p>In practice, compilers can generate machine code that makes use of this register to store the frame pointer and then use it to locate certain variables/object that resides within the stack. They can technically just use the SP stack pointer, but that pointer is dynamic! It moves during the runtime so it&rsquo;s harder (maybe impossible?) to use it to access local variables. Frame pointers, however, are static and do not change during a function&rsquo;s lifetime. So, they can be easily used to calculate variable locations.</p>
<p>X30: Last, but not least, the link register! Have you ever wondered when a function is called how does it know where to return after? Well, the link register is how.
Before a thread executes the BL branch with link instruction (basically calling a function) the link register is set to the current PC program counter so that when the function returns with RET this register would be pointing to the caller function. The exact value hold in it is the address of the NEXT instruction right after BL.</p>
<p>insert link register example here</p>
<p>The link register only holds the one-previous function&rsquo;s address. So, what about nested function calls?
AAPCS64 further details that before calling a function and modifying the link register, its current value should be pushed to the stack. And then, when the called function returns, the value is popped and written back to the link register. Therefore, preserving the order of function calls!</p>
<blockquote>
<p>One last thing I want to talk shortly about is SIMD registers. AAPCS64 also talks about them, but not in great detail compared to general-purpose ones as their purpose is pretty straightforward.</p>
</blockquote>
<blockquote>
<p>SIMD registers are named V0 … V31. The first eight (8) register V0 … V7 are used to pass parameters and to return the result value from a function. Registers V8 … V17 are callee-preserved registers that have seen before. The rest can be used as a scratch register like normal.</p>
</blockquote>
<h1 id="caller-saved--callee-saved">Caller-Saved &amp; Callee-Saved</h1>
<p>When I first saw these terms, I was confused. Why would someone categorize the scratch registers into caller &amp; callee saved? Why shouldn&rsquo;t I just use them however I want? Technically, yes, you can use them freely. But, there are two things  you need to be aware of: optimization and modularity.</p>
<p>Remember the following:</p>
<ul>
<li>X0 … X7: Used to pass the first eight (8) parameters</li>
<li>X9 … X15: Caller-saved registers</li>
<li>X19 … X28: Callee-saved registers</li>
</ul>
<p>Let&rsquo;s talk about an example C++ code. Don&rsquo;t worry about the naming and such; I created it just to show how registers are used within GCC.</p>
<div class="highlight"><pre tabindex="0" style="color:#4d4d4d;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#5918bb;font-weight:bold">uint64_t</span> <span style="color:#ff8000;font-weight:bold">loop</span>(<span style="color:#5918bb;font-weight:bold">uint64_t</span> a, <span style="color:#5918bb;font-weight:bold">uint64_t</span> b, <span style="color:#5918bb;font-weight:bold">uint64_t</span> c, <span style="color:#5918bb;font-weight:bold">uint64_t</span> d, <span style="color:#5918bb;font-weight:bold">uint64_t</span> e, <span style="color:#5918bb;font-weight:bold">uint64_t</span> f, <span style="color:#5918bb;font-weight:bold">uint64_t</span> g, <span style="color:#5918bb;font-weight:bold">uint64_t</span> h) {
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> result <span style="color:#2c5dcd">=</span> <span style="color:#5918bb;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">for</span> (<span style="color:#5918bb;font-weight:bold">int</span> i <span style="color:#2c5dcd">=</span> <span style="color:#5918bb;font-weight:bold">0</span>; i <span style="color:#2c5dcd">&lt;</span> <span style="color:#5918bb;font-weight:bold">16</span>; <span style="color:#2c5dcd">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#0080ff;font-style:italic">// Random calculations on the function parameters
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>        a <span style="color:#2c5dcd">+=</span> b <span style="color:#2c5dcd">+</span> c <span style="color:#2c5dcd">*</span> d;
</span></span><span style="display:flex;"><span>        b <span style="color:#2c5dcd">^=</span> e <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>        c <span style="color:#2c5dcd">*=</span> f <span style="color:#2c5dcd">+</span> g;
</span></span><span style="display:flex;"><span>        d <span style="color:#2c5dcd">-=</span> h <span style="color:#2c5dcd">*</span> a;
</span></span><span style="display:flex;"><span>        e <span style="color:#2c5dcd">+=</span> f <span style="color:#2c5dcd">^</span> g;
</span></span><span style="display:flex;"><span>        f <span style="color:#2c5dcd">=</span> (g <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">3</span>) <span style="color:#2c5dcd">-</span> d;
</span></span><span style="display:flex;"><span>        g <span style="color:#2c5dcd">+=</span> h <span style="color:#2c5dcd">*</span> e;
</span></span><span style="display:flex;"><span>        h <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">|</span> b <span style="color:#2c5dcd">|</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0080ff;font-style:italic">// Call another function
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>        result <span style="color:#2c5dcd">+=</span> <span style="color:#ff8000;font-weight:bold">calc</span>(a, b, c, d, e, f, g, h);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All it does is just do some calculations on eight (8) different variables, with each being taken as a parameter. After that, they are all passed to another function that does even more calculation. Let&rsquo;s see it.</p>
<div class="highlight"><pre tabindex="0" style="color:#4d4d4d;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#5918bb;font-weight:bold">uint64_t</span> <span style="color:#ff8000;font-weight:bold">calc</span>(<span style="color:#5918bb;font-weight:bold">uint64_t</span> a, <span style="color:#5918bb;font-weight:bold">uint64_t</span> b, <span style="color:#5918bb;font-weight:bold">uint64_t</span> c, <span style="color:#5918bb;font-weight:bold">uint64_t</span> d, <span style="color:#5918bb;font-weight:bold">uint64_t</span> e, <span style="color:#5918bb;font-weight:bold">uint64_t</span> f, <span style="color:#5918bb;font-weight:bold">uint64_t</span> g, <span style="color:#5918bb;font-weight:bold">uint64_t</span> h) {
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> a1 <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, b1 <span style="color:#2c5dcd">=</span> b <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, c1 <span style="color:#2c5dcd">=</span> c <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, d1 <span style="color:#2c5dcd">=</span> d <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> e1 <span style="color:#2c5dcd">=</span>  e<span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, f1 <span style="color:#2c5dcd">=</span> f <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, g1 <span style="color:#2c5dcd">=</span> g <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, h1 <span style="color:#2c5dcd">=</span> h <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// More local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> i <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">10</span>, j <span style="color:#2c5dcd">=</span> b <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">20</span>, k <span style="color:#2c5dcd">=</span> c <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">30</span>, l <span style="color:#2c5dcd">=</span> d <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">40</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> m <span style="color:#2c5dcd">=</span> e <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">50</span>, n <span style="color:#2c5dcd">=</span> f <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">60</span>, o <span style="color:#2c5dcd">=</span> g <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">70</span>, p <span style="color:#2c5dcd">=</span> h <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">80</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Random calculations on the local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    a1 <span style="color:#2c5dcd">+=</span> b1 <span style="color:#2c5dcd">-</span> c1 <span style="color:#2c5dcd">*</span> d1;
</span></span><span style="display:flex;"><span>    b1 <span style="color:#2c5dcd">^=</span> e1 <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    c1 <span style="color:#2c5dcd">*=</span> f1 <span style="color:#2c5dcd">-</span> g1;
</span></span><span style="display:flex;"><span>    d1 <span style="color:#2c5dcd">+=</span> h1 <span style="color:#2c5dcd">/</span> a1;
</span></span><span style="display:flex;"><span>    e1 <span style="color:#2c5dcd">+=</span> f1 <span style="color:#2c5dcd">^</span> g1;
</span></span><span style="display:flex;"><span>    f1 <span style="color:#2c5dcd">=</span> (g1 <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">2</span>) <span style="color:#2c5dcd">+</span> d1;
</span></span><span style="display:flex;"><span>    g1 <span style="color:#2c5dcd">-=</span> h1 <span style="color:#2c5dcd">*</span> e1;
</span></span><span style="display:flex;"><span>    h1 <span style="color:#2c5dcd">=</span> a1 <span style="color:#2c5dcd">&amp;</span> b1 <span style="color:#2c5dcd">&amp;</span> c1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i <span style="color:#2c5dcd">+=</span> j <span style="color:#2c5dcd">*</span> k <span style="color:#2c5dcd">-</span> l;
</span></span><span style="display:flex;"><span>    j <span style="color:#2c5dcd">^=</span> m <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">3</span>;
</span></span><span style="display:flex;"><span>    k <span style="color:#2c5dcd">*=</span> n <span style="color:#2c5dcd">+</span> o;
</span></span><span style="display:flex;"><span>    l <span style="color:#2c5dcd">-=</span> p <span style="color:#2c5dcd">*</span> i;
</span></span><span style="display:flex;"><span>    m <span style="color:#2c5dcd">+=</span> n <span style="color:#2c5dcd">^</span> o;
</span></span><span style="display:flex;"><span>    n <span style="color:#2c5dcd">=</span> (o <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">2</span>) <span style="color:#2c5dcd">-</span> l;
</span></span><span style="display:flex;"><span>    o <span style="color:#2c5dcd">+=</span> p <span style="color:#2c5dcd">*</span> m;
</span></span><span style="display:flex;"><span>    p <span style="color:#2c5dcd">=</span> i <span style="color:#2c5dcd">|</span> j <span style="color:#2c5dcd">|</span> k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Return the result [X0]
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> result <span style="color:#2c5dcd">=</span> a1 <span style="color:#2c5dcd">+</span> b1 <span style="color:#2c5dcd">+</span> c1 <span style="color:#2c5dcd">+</span> d1 <span style="color:#2c5dcd">+</span> e1 <span style="color:#2c5dcd">+</span> f1 <span style="color:#2c5dcd">+</span> g1 <span style="color:#2c5dcd">+</span> h1 <span style="color:#2c5dcd">+</span> i <span style="color:#2c5dcd">+</span> j <span style="color:#2c5dcd">+</span> k <span style="color:#2c5dcd">+</span> l <span style="color:#2c5dcd">+</span> m <span style="color:#2c5dcd">+</span> n <span style="color:#2c5dcd">+</span> o <span style="color:#2c5dcd">+</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Basically calc(&hellip;) is just more calculation. But this time the amount of variables incresed. It now has sixteen (16) local variables with each being used to calculate the final result (X0).</p>
<p>Our problem is this: Generate a good &amp; efficient machine code that utilizes register usage instead of accessing the memory using the AAPCS64.</p>
<p>Option 1) Use stack to save those registers</p>
<p>This is the naive way of doing this. The code becomes simpler, yes. But you would be accessing the memory way more often. All those sweet scratch registers are sitting empty;( Meaning, you are missing out on optimization!</p>
<p>Here&rsquo;s the ARM64 gcc 13.2.0 compiler with no optimization. Also, see the full code on godbolt.org: <a href="https://godbolt.org/z/T9GKG96Tz">https://godbolt.org/z/T9GKG96Tz</a></p>
<p>insert option 1) godbolt.org output here</p>
<p>Option 2) Use the scratch registers:</p>
<p>Now the fun begins by thinking smart. We have the following 25 register at our disposal: X0 … X7, X9 … X15 and X19 … X28. We could just save each variable to an empty register. But what if someone were using that (e.g., previous function)? We can&rsquo;t just assume they are free to use, otherwise we risk corrupting the whole program.</p>
<p>What we can do is push ALL the registers onto the stack and freely use the registers. After we are done, we could just pop them out. Alright… we are getting somewhere. However, still we are accessing the stack, still we are accessing the memory! There must be a smarter way of doing this.</p>
<p>It seems we need a way to tell which registers are free to use. So that can avoid pushing ALL register to stack vs. SOME registers. And guess what? AAPCS64 explicitly talks about this!</p>
<p>insert AAPCS64 caller-saved and caller-saved registers here</p>
<p>Here, we are introduced to caller-saved and callee-saved registers. I&rsquo;m not going to repeat what&rsquo;s written in AAPCS64. Instead, I will give you the intuition. </p>
<p>Caller-saved registers ( X9 … X15). If you DO NOT care about what happens to a temporary value after a function call, then use these registers. They are also called volatile registers for this exact reason. The values MIGHT be changed by the function, so DO NOT use them to store values you want to keep after a function call.</p>
<ul>
<li>From the caller&rsquo;s perspective: Assume registers are to be destroyed </li>
<li>From the callee&rsquo;s perspective: Freely use the registers</li>
</ul>
<blockquote>
<p>You might wonder, then why they are named caller-saved? Frankly, idk. The caller COULD save them to stack if it wants, but does NOT have to. So, I (and many others) think the name is misleading.</p>
</blockquote>
<p>Callee-saved registers ( X19 … X28). If you DO care about the retaining a temporary value after a function call, then use these registers. They are also called non-volatile registers for this exact reason. Assume that the values are to be RETAINED and you must save them to the stack before doing anything to them. Interesting thing her is it is NOT the caller, but the callee that should save them. As to why? I don&rsquo;t know.
From the caller&rsquo;s perspective: Do nothing. They won&rsquo;t be changed
From the callee&rsquo;s perspective: Save them to stack &amp; then restore after</p>
<p>insert caller-saved vs. callee-saved registers here</p>
<p>Now, we have enough information on our hand about the scratch registers. We can use this to optimize our code. As to how? I don&rsquo;t really know. This is an area where compiler engineers work to optimize. Each different compiler and their version will use these registers differently.</p>
<p>Let&rsquo;s look at the code generated by ARM64 gcc 13.2.0 with the -O1 optimization flag. Also, see the full code on godbolt.org: <a href="https://godbolt.org/z/ETc81YadG">https://godbolt.org/z/ETc81YadG</a></p>
<p>insert option 2) godbolt.org output here</p>
<p>Notice how BOTH the caller-saved and callee-saved registers are used. Again, how compilers decide on which to use depends on its design &amp; goals.</p>
<h1 id="closing-words">Closing Words</h1>
<p>And with all that, we know have a little bit more information about AAPCS64 and how calling conventions work. There is a lot to unpack here. Don&rsquo;t feel bad if you don&rsquo;t understand each and everything. Just keep reading, practicing and learning. I highly encourage you to come to this writing again after a couple of weeks. After some time, your brain would be done processing everything. By reading this again, everything then would make a lot more sense. And who knows, maybe you would learn A NEW thing you missed during the first time.</p>
<p>I want to point out that lot&rsquo;s of details were left out to keep things simple &amp; straightforward. AAPCS64 is a long document with many technical details. For the purpose of this writing I didn&rsquo;t talk about them. Keeping everything on ELI5 level was my goal.</p>
<p>By cutting and compressing everything from the AAPCS64, I might&rsquo;ve made some mistakes. If you think there is one, feel free to contact me. I wouldn&rsquo;t want to give wrong information.</p>
<p>And lastly, thanks for reading.</p>
<p>Enjoy Life ❤</p>

    </div>
	<div class="post-footer">
		<hr />

		<img src="/blog/signature.png" alt="signature" style="height: 55px;" />

		<p>Thanks for reading & Take care <span style="font-style: normal;"> ❤ </span></p>
		<p>
			Follow me on
			<a href="https://twitter.com/tunacicii">X (formerly Twitter)</a>,
      if you like my works that is >.&lt;
		</p>

	</div>
  </article>

  <hr />

  <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/memes/">Memes</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <nav id="TableOfContents"></nav>
    </div>

    <div id="share-footer" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f">
      <i class="fab fa-facebook fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&text=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-twitter fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-linkedin fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&is_video=false&description=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-pinterest fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI&body=Check out this article: http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f">
      <i class="fas fa-envelope fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-reddit fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-digg fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&name=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI&description=insert%20header%20here%0aProgramming%20using%20high-level%20languages%20makes%20a%20ton%20of%20stuff%20trivial.%20Your%20compiler%2finterpreter%20abstracts%20a%20lot%20of%20stuff%20from%20you%20so%20that%20you%20can%20focus%20on%20what%26rsquo%3bs%20important%3a%20getting%20shit%20done%2c%20efficiently.%20One%20of%20those%20abstractions%20is%20functions.%0aCalling%20function%20is%20one%20of%20the%20first%20things%20you%20learn%20when%20starting%20programming.%20They%20are%20relatively%20trivial%3a%20you%20just%20type%20the%20function%20name%2c%20pass%20some%20parameters%20and%20then%20it%20does%20what%20it%26rsquo%3bs%20meant%20to%20do%20%28or%20not%29.">
      <i class="fab fa-tumblr fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=http%3a%2f%2flocalhost%3a1313%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-calling-conventions-machine-registers-abi%2f&t=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20Calling%20Conventions%2c%20Machine%20Registers%20%26%c2%a0ABI">
      <i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>

    <div id="actions-footer">
      
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;">
          <i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;">
          <i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;">
          <i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
          <i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>


  <footer id="footer">
  <div class="footer-left">
    Pasteleft &#9752; 2024  Tuna Cici (Blog) 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/blog/lib/font-awesome/css/all.min.css>
<script src=/blog/lib/jquery/jquery.min.js></script>
<script src=/blog/js/main.js></script>



</html>
