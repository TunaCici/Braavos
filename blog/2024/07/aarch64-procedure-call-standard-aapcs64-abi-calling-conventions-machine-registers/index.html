<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> AArch64 Procedure Call Standard (AAPCS64): ABI, Calling Conventions &amp; Machine Registers | Tuna Cici (Blog)</title>
  <meta name="description" content="Enjoy Life!">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:url" content="https://tunacici.com/blog/2024/07/aarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers/">
  <meta property="og:site_name" content="Tuna Cici (Blog)">
  <meta property="og:title" content="AArch64 Procedure Call Standard (AAPCS64): ABI, Calling Conventions &amp; Machine Registers">
  <meta property="og:description" content="Programming using high-level languages makes a ton of stuff trivial. Your compiler/interpreter abstracting lots stuff from you so that you can focus on what&amp;rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.
Calling a function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&amp;rsquo;s meant to do (or not).">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
  <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-24T00:00:00+00:00">
    <meta property="article:tag" content="Aarch64">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Assembly">
    <meta property="article:tag" content="Eli5">

  <meta name="twitter:card" content="summary"><meta name="twitter:title" content="AArch64 Procedure Call Standard (AAPCS64): ABI, Calling Conventions &amp; Machine Registers">
<meta name="twitter:description" content="Programming using high-level languages makes a ton of stuff trivial. Your compiler/interpreter abstracting lots stuff from you so that you can focus on what&rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.
Calling a function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&rsquo;s meant to do (or not).">

  
  
    
  
  
  <link rel="stylesheet" href="/blog/css/style-white.css">
  
   <link rel="stylesheet" href="/blog/css/custom.css"> 
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  <link rel="icon" type="image/png" href="/favicon.ico" />
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

  <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li>
          <a class="icon" href=" https://tunacici.com/blog/2023/11/first-stage-loaders-bios-uefi-iboot1-u-boot-spl/">
            <i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i>
          </a>
        </li>
        
        
        <li>
          <a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
            <i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i>
          </a>
        </li>
        <li>
          <a class="icon" href="#">
            <i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i>
          </a>
        </li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f">
      <i class="fab fa-facebook " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&text=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-twitter " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-linkedin " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&is_video=false&description=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-pinterest " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers&body=Check out this article: https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f">
      <i class="fas fa-envelope " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-get-pocket " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-reddit " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-stumbleupon " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-digg " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&name=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers&description=Programming%20using%20high-level%20languages%20makes%20a%20ton%20of%20stuff%20trivial.%20Your%20compiler%2finterpreter%20abstracting%20lots%20stuff%20from%20you%20so%20that%20you%20can%20focus%20on%20what%26rsquo%3bs%20important%3a%20getting%20shit%20done%2c%20efficiently.%20One%20of%20those%20abstractions%20is%20functions.%0aCalling%20a%20function%20is%20one%20of%20the%20first%20things%20you%20learn%20when%20starting%20programming.%20They%20are%20relatively%20trivial%3a%20you%20just%20type%20the%20function%20name%2c%20pass%20some%20parameters%20and%20then%20it%20does%20what%20it%26rsquo%3bs%20meant%20to%20do%20%28or%20not%29.">
      <i class="fab fa-tumblr " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&t=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-hacker-news " aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>
    <div id="toc">
      <nav id="TableOfContents"></nav>
    </div>
  </span>
</div>

<div class="alert-warning">
	⭐️	
	<a href="https://tunacici.com/blog/2024/07/aarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers/">New writing: AAPCS64 Procedure Call Standard - Jul 25, 2024</a>
	⭐️
</div>


  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
    
      <img src="header.png" class="hero" alt="Procedure Call Standard - Arm 64-bit Architecture (AArch64)" />
    

      <h1 class="posttitle" itemprop="name headline">
        AArch64 Procedure Call Standard (AAPCS64): ABI, Calling Conventions &amp; Machine Registers
      </h1>
      <div class="meta">
        
        <div class="postdate">
          
          <time datetime="2024-07-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2024-07-24</time>
          
        </div>
        
        
        <div class="article-tag">
            <i class="fas fa-tag"></i>
            
            
            <a class="tag-link" href="/tags/aarch64/" rel="tag">aarch64</a>
            
             ,  
            <a class="tag-link" href="/tags/c/" rel="tag">c</a>
            
             ,  
            <a class="tag-link" href="/tags/assembly/" rel="tag">assembly</a>
            
             ,  
            <a class="tag-link" href="/tags/eli5/" rel="tag">eli5</a>
            
        </div>
        
      </div>
    </header>

  
    <div class="content" itemprop="articleBody">
      <p>Programming using high-level languages makes <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)">a ton of stuff</a> trivial. Your compiler/interpreter <a href="https://en.wikipedia.org/wiki/Data_type">abstracting lots stuff</a> from you so that you can focus on what&rsquo;s important: getting shit done, efficiently. One of those abstractions is functions.</p>
<p>Calling a function is one of the first things you learn when starting programming. They are relatively trivial: you just type the function name, pass some parameters and then it does what it&rsquo;s meant to do (<a href="https://science.nasa.gov/mission/mariner-1/">or not</a>). You don&rsquo;t need to think about whether the underlying CPU architecture is 64-bit or that it&rsquo;s by AMD, Intel or Apple. All you care is that the function gets called, does its thing and successfully returns. That is until you need to get real <a href="https://x.com/FFmpeg/status/1805687815294140542">close to the hardware</a>, <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_60.html">debug on register-level</a> or d<a href="https://www.cse.unsw.edu.au/~cs9242/19/exam/paper1.pdf">esign system-level programs &amp; languages</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#4d4d4d;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#5918bb;font-weight:bold">int</span> <span style="color:#ff8000;font-weight:bold">main</span>(<span style="color:#5918bb;font-weight:bold">int</span> argc, <span style="color:#5918bb;font-weight:bold">char</span> <span style="color:#2c5dcd">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">/* Call to standard library */</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#2c5dcd">::</span>cout <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#0c6">&#34;Hello, world!&#34;</span> <span style="color:#2c5dcd">&lt;&lt;</span> std<span style="color:#2c5dcd">::</span>endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">/* Call to external library */</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#2c5dcd">::</span>string world <span style="color:#2c5dcd">=</span> <span style="color:#0c6">&#34;world&#34;</span>;
</span></span><span style="display:flex;"><span>    fmt<span style="color:#2c5dcd">::</span><span style="color:#ff8000;font-weight:bold">print</span>(<span style="color:#0c6">&#34;Hello, {}!</span><span style="color:#c5060b;font-weight:bold">\n</span><span style="color:#0c6">&#34;</span>, world);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">/* Call to my own function */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff8000;font-weight:bold">my_print_hello</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * They are cool and all, but:
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * How do they work under-the-hood?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * How am I able to use external functions/APIs?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * What happens at the machine code level?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * How are parameters passed around?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * What happens if I have too many parameters?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * Is there a limit to amount of parameters I can define?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * How does a pre-compiled library works on my machine?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     * Why does my CPU or its architecture matter?
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">return</span> <span style="color:#5918bb;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>At that point it is good to know how the compiler, the standard library and the kernel/OS handles functions. For example, you might need to consider how stack is managed, how are functions called to &amp; returned from, how parameters are passed (via registers or stack). They all depend on your specific platform (e.g., AMD64, AArch64) and the kernel/OS (e.g., Linux, macOS).</p>
<p>Here, I will try to <a href="https://www.urbandictionary.com/define.php?term=ELI5">ELI5</a> those abstractions and concepts for the AArch64 platforms. Throughout this writing, I will assume that you are familiar with stuff like <a href="https://en.wikipedia.org/wiki/Compiler">compilers</a>, <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linkers</a>, <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/docs/elf.pdf">ELF format</a>, <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a> and <a href="https://cs.lmu.edu/~ray/notes/gasexamples/">basic assembly code</a>. Feel free to stop reading at any point and gain more insight on those topics as they will help broaden your knowledge on system-level programming &amp; computer hardware;)</p>
<h1 id="i-calling-conventions-api-andabi">I. Calling Conventions, API and ABI</h1>
<p>Everyone writes programs in their own way. The compiler they choose to use can also be different; so does the hardware they worked on; or even the programming language itself. All these (and many other) factors can affect the final machine code of the program. </p>
<p><img src="./same-code-diff-output.png" alt=""></p>
<p>Same C++ Code Compile /w GCC and Clang/LLVM</p>
<p>Naturally, we expect our programs to behave the same with the same code; doesn&rsquo;t matter the compiler or the underlying hardware. If I wrote a static/dynamic library for others to use (e.g., <a href="https://github.com/openssl/openssl"><code>libssl</code></a>, <a href="https://github.com/curl/curl"><code>libcurl</code></a>) I expect it to work for the platform I compiled it to, whether AMD64 or AArch64. The kernel/OS version, CPU generation (e.g. Apple <a href="https://www.apple.com/newsroom/2020/11/apple-unleashes-m1/">M1</a> vs <a href="https://www.apple.com/newsroom/2024/05/apple-introduces-m4-chip/">M4</a>) or the compiler version should NOT matter. How is this achieved?</p>
<p>I mean, really think about it: How does a program or library you download from the internet work on your machine? Even the CPU you have might not have been around when the program was first compiled!</p>
<h1 id="functions">Functions</h1>
<p>A function can be defined as a block of code with a well-defined interface and behavior that can be called multiple times. The program/code that calls the function is called <code>caller</code>, and the function itself is called <code>callee</code>. The interface of a function is particularly interesting.</p>
<h1 id="api">API</h1>
<p>On higher-level languages the interface of a function is also called an API (Application Programming Interface). Programmers must know this interface to make a function call. The order of the parameters, and their type matters for languages like C, Rust, Java. However, languages like Python and Ruby support <a href="https://en.wikipedia.org/wiki/Named_parameter">named parameters</a>, where the order doesn&rsquo;t &ldquo;really matter&rdquo;.</p>
<p><img src="./basic-func-declr.png" alt="">
Some Basic Function Declarations in C++, Swift and Python</p>
<p>APIs are higher-level interfaces. They have language-specific parameters and types. So, they are generally intended to be used for the language they are written in. But in the end they are all compiled into machine code and programs talk with each other with machine code; not C or Swift.</p>
<p>We have seen from previous images that even if the code might be the same, the compiled machine code can be different. And if the machine code is different: how would the APIs work?</p>
<p>Below is an example function that&rsquo;s compiled using two different compilers /w different machine code. Yet, they work. How?</p>
<p><img src="diff-machine-code-still-works.png" alt="">
Compiling Two Different Source Codes With Two Different Compilers - Linking Still Works!</p>
<h1 id="abi">ABI</h1>
<p><img src="similar-code.png" alt=""></p>
<p>In the above image, notice how even if the machine code is generally different, some stuff is the same. Especially the begging and the end. And it&rsquo;s not just mere coincidence. The code you see there is called ABI (Application Binary Interface). They define how functions (or subroutines) should be called and returned from at the machine code level. You can compare them to APIs; the idea is the same, but the language and the level they work on is different.</p>
<p><img src="api-vs-abi.png" alt="">
API vs. ABI -Just  Note That They Are Not Exactly Comparable; I Just Want to Give an Idea</p>
<p>Just like how the design of an API is unique to the author of the software, the design of an ABI is also unique to the it&rsquo;s platform. There are many design factors that defines an ABI (e.g., calling conventions, data type &amp; alignment). The one we will be focus on is Procedure Call Standard (PCS) for AArch64 platforms. Also known as - calling convention for AArch64.</p>
<blockquote>
<p>I won&rsquo;t be explaining the data types &amp; alignment as to keep this  writing on topic: calling conventions. They deserve their own writing, which I might do on another time;)</p>
</blockquote>
<p><img src="aapcs64-doc.png" alt="">
Reference AAPCS64 Document</p>
<h1 id="calling-conventions">Calling Conventions</h1>
<p>A Calling Convention is a scheme that defines how functions receive their parameters and return their results. They specify how a program should handle functions at the machine code level. Below are some of the schemes that they define (not limited to):</p>
<ul>
<li>How parameters are passed &amp; returned</li>
<li>Which registers the callee must preserve</li>
<li>How the stack should be managed between the callee and caller</li>
</ul>
<blockquote>
<p>From now on I will use the ABI and calling convention interchangeably to keep things on ELI5 level. But know that they are NOT the same time. Calling conventions are just a subset of ABI design.</p>
</blockquote>
<p>Each platform has their own conventions, but the sane ones usually share a lot of similarities. Below are the preferred calling conventions for each widely used platforms.</p>
<ul>
<li>AMD64 (x86_64): <a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf">Sytem V ABI</a></li>
<li>AArch64 (ARM64): <a href="https://student.cs.uwaterloo.ca/~cs452/docs/rpi4b/aapcs64.pdf">Procedure Call Standard for AArch64</a></li>
<li>RISC-V: <a href="https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf">RISC-V Calling Convention</a></li>
<li>PowerPC: <a href="https://www.ibm.com/docs/en/aix/7.3?topic=overview-register-usage-conventions">System V ABI for PowerPC</a></li>
</ul>
<p><img src="platforms-abis.png" alt="">
Platforms and The ABI They Use</p>
<p>The one we are focusing on is AArch64. But before we move on to that, let&rsquo;s talk about registers and stack as they are the foundation which a calling convention is build upon.</p>
<h1 id="ii-machine-registers">II. Machine Registers</h1>
<p>There are many registers defined in AArch64 and the availability of them depends on the architecture version (e.g., <a href="https://developer.arm.com/documentation/102378/0201/Armv8-x-and-Armv9-x-extensions-and-features">ARMv8</a>, <a href="https://developer.arm.com/documentation/ddi0608/latest/">ARMv9</a>) and the platform vendor. However, all of them are at least expected to implement the basic register banks: general-purpose and SIMD. We will focus on general-purpose registers and what their purposes.</p>
<h1 id="general-purpose-registers">General-Purpose Registers</h1>
<p><img src="aarch64-general-purpose-registers.png" alt="">
AArch64 General Purpose Registers</p>
<p>AArch64 provides 31 general-purpose registers, each 64 bits wide. They are named <code>X0 … X30</code>. Although the general-purpose registers are equal and interchangeable at the architecture level, in practice their purpose is defined by the AAPCS64 which most sane compilers/programmers adhere.</p>
<blockquote>
<p>The following sections are taken from <a href="https://www.wiley.com/en-us/Blue+Fox%3A+Arm+Assembly+Internals+and+Reverse+Engineering-p-9781119745303">Maria Azeria Markstedter&rsquo;s ARM Assembly: Internals &amp; Reverse Engineering</a> book. Shout out to her for the great book!</p>
</blockquote>
<h1 id="x0-x7">X0-X7</h1>
<p>These registers are used for argument registers to pass parameters and return a result. More on this later.</p>
<h1 id="x8">X8</h1>
<p><a href="https://github.com/Siguza/ios-resources/blob/master/bits/arm64.md">Pointer to where to write the return value if &gt;128 bits, otherwise scratch register</a>. It can be used to pass the address location of an indirect result.</p>
<h1 id="x915">X9–15</h1>
<p>These are caller-saved temporary registers used to preserve values across a call to another function. The affected registers are saved in the stack frame of the caller function, allowing the callee function to modify these registers.</p>
<h1 id="x16-x17">X16-X17</h1>
<p>These are intraprocedure-call temporary registers that can be used as temporary registers for immediate values between function calls. They can be used for ordinary computations within any given function. However, AAPCS64 gives them a different purpose.</p>
<p>For example, if a program calls a function defined in a shared library such as <code>malloc()</code>, this function call may be implemented via a call through the <a href="https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table">procedure linkage table (PLT)</a> to call the <code>malloc()</code> implementation inside another module.</p>
<p>The PLT stub responsible for find and transferring execution to the <code>malloc()</code> function in the other library can use the X16 and X17 registers as intraprocedural call registers freely, without having to take care not to corrupt their values. LLVM, for example, will compile PLT stubs that make use of X16 and X17. </p>
<blockquote>
<p>Also see <a href="https://developer.arm.com/documentation/101754/0622/armlink-Reference/Image-Structure-and-Generation/Linker-generated-veneers">GCC&rsquo;s veneer</a> for more examples on X16 and X17 usage.</p>
</blockquote>
<p><img src="veneer.png" alt="">
This Code Is From My <a href="https://github.com/TunaCici/WesterOS">WesterOS Kernel</a>  -  Notice How <code>__kmain_veneer</code> Is Called Instead of <code>kmain()</code></p>
<h1 id="x18-platform-register">X18 (Platform Register)</h1>
<p>The X18 platform is a general-purpose register like any. The AAPCS, however, reserves it to be the platform register, pointing to some platform-specific data. More on this later.</p>
<h1 id="x19-x28">X19-X28</h1>
<p>These are callee-saved registers that are saved in the stack frame of the called function, allowing the function to modify these registers but also requiring it to restore them before returning to the caller.</p>
<h1 id="x29-fp">X29 (FP)</h1>
<p>It is used as a frame pointer (FP) to keep track of the stack frame. More on this later.</p>
<h1 id="x30-lr">X30 (LR)</h1>
<p>It is the link register (LR) holding the return address of the function. More on this later.</p>
<h1 id="overview">Overview</h1>
<p>Below image gives a basic overview on all the general purpose registers we have seen so far.</p>
<p><img src="aarch64-general-purpose-registers-w-purposes.png" alt="">
AArch64 General Purpose Register /w Purposes</p>
<h1 id="simd-and-floating-point-registers">SIMD and Floating-Point Registers</h1>
<p>In addition to the 64-bit general-purpose registers, AArch64 also supplies a series of 32 x 128-bit vector registers for use in optimized single instruction multiple data (SIMD) operations for performing floating-point arithmetic. These registers are each 128-bits long and named <code>V0 … V31</code>.</p>
<p>Similar to general-purpose registers, the  first eight SIMD registers <code>V0 … V7</code> are used for argument registers to pass parameters and return a result. The rest is either used as scratch registers. However, there are some calling convention details. More on this later.</p>
<p><img src="aarch64-simd-registers-w-purposes.png" alt="">
AArch64 SIMD Register /w Purposes</p>
<h1 id="iii-aapcs64">III. AAPCS64</h1>
<p>Most platform&rsquo;s author/owner describes their calling conventions for public use. After all that&rsquo;s what they are meant for: for everyone to use and adapt. We are currently only interested in Arm&rsquo;s.</p>
<p>Arm® Architecture describes their calling conventions <a href="https://github.com/ARM-software/abi-aa">on their GitHub page</a> named <strong>Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)</strong>. We will shortly call it: <strong>AAPCS64</strong>. </p>
<blockquote>
<p>There are other documents on that Arm&rsquo;s GitHub page that further describes their ABI. Check them out if you are curious!</p>
</blockquote>
<p><img src="arm64-abi-docs.png" alt="">
ABI Documents  -  Check Out: <a href="https://github.com/ARM-software/abi-aa">https://github.com/ARM-software/abi-aa</a></p>
<p>Inside the AAPCS64 there are multiple sections and each deserve their own writings. We are only going to talk about calling conventions, but for the curious: here&rsquo;s other sections that&rsquo;s described in it:</p>
<ul>
<li><a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#data-types-and-alignment">Data Type and Alignment</a></li>
<li><a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#the-base-procedure-call-standard">The Base Procedure Call Standard</a></li>
<li><a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#the-standard-variants">Standard Variations</a></li>
<li><a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#arm-c-and-c-language-mappings">C and C++ Language Mappings</a></li>
</ul>
<p>AAPCS64 is kind of a long and it would be pointless to explain everything in it. I will only talk about the parts that I consider to be the most useful when doing casual programming for AArch64 platforms.</p>
<h1 id="parameter-passing">Parameter Passing</h1>
<p>Naturally, [on any language] when doing a function call, the caller and the callee must agree on how to pass parameters at the machine code level. AAPCS64 defines this in section <a href="https://github.com/ARM-software/abi-aa#id48">6. The Base Procedure Call Standard.</a> It describes that:</p>
<ul>
<li><code>X0 … X7</code>: Should be used for the first eight (8) parameters</li>
<li><code>Stack</code>: Should be used for any additional parameters</li>
</ul>
<p>I think it is pretty straightforward. We can even see this in action. Let&rsquo;s look at an <a href="https://godbolt.org/z/KrMMWo7fc">example C function</a> with 4, 8 and 12 parameters.</p>
<p><img src="c-many-params.png" alt="">
Assembly Code of sum4(), sum8() and sum12()  -  Notice How Arguments Are Stored in X0 … X7 and/or The Stack</p>
<p>As you can see the first (1st) parameter is stored in <code>X0</code>, second (2nd) in <code>X1</code>, third (3rd) in <code>X2</code> and so on… After the eight (8th) the additional parameters are stored in thread stack. This is where things get interesting.</p>
<p>Stating the obvious: <a href="https://www.mikeash.com/pyblog/friday-qa-2013-10-11-why-registers-are-fast-and-ram-is-slow.html">CPU registers are fast and stack memory is slow</a>. We want to stay away from accessing the memory as much as possible. Generally, compilers are pretty good at optimizing on this and you won&rsquo;t have to worry about the amount of parameter a function takes.</p>
<p>Sometimes, however, you might need those extra nano/microseconds (e.g., low-latency systems).</p>
<h1 id="result-return">Result Return</h1>
<p>This one, again, is pretty straightforward and clear. AAPCS64 states that the function return value should be stored in:</p>
<ul>
<li><code>X0</code> </li>
</ul>
<p>You can see from the below C function that the uint64_t return value is stored in <code>X0</code> before the call to <a href="https://developer.arm.com/documentation/dui0802/b/A64-General-Instructions/RET"><code>RET</code></a> (function return).</p>
<p><img src="x0-highlighted.png" alt="">
Notice The Modified X0 Before The Call to Ret (Function Return)  -  Just FYI: D0 is Basically X0 But for Floating</p>
<blockquote>
<p>Personal note: I always wondered why C/C++ functions always returned only one value. What if I want to return two values like 2D coordinates of {x, y}? Well, now I know: the ABI just doesn&rsquo;t support it. Probably for good reasons.</p>
</blockquote>
<blockquote>
<p>Later, however, I learned about objects/structs and then used them to &ldquo;return more than one value&rdquo;. But still, at the machine code level, a function still returns one value: reference/pointer to an object.</p>
</blockquote>
<h1 id="the-stack">The Stack</h1>
<p>Almost all modern languages use the concept of stack. They are used for various reasons. I would like to give examples but am no language designer;( One thing I know is that they are used when calling functions.</p>
<blockquote>
<p>The next parts assume that any language is designed to make use of the stack. There are, however, languages that DON&rsquo;T have stack. See <a href="https://web.archive.org/web/20100706035639/http://www.linux-mag.com/cache/7373/1.html">Parrot</a> or <a href="https://www.defmacro.org/2006/06/19/fp.html">other functional languages</a>.</p>
</blockquote>
<p>Each thread in a program has its own stack. <a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#the-stack">According to AAPCS64</a>, a stack is a continuous memory region that the thread can use for storage of local variables and for passing additional arguments [if the first eight (8) register are insufficient].</p>
<p><img src="c-stack-overview.png" alt="">
Overview of a Program&rsquo;s Address Space &amp; Its [Imaginary] Stack</p>
<p>The concept of stack is a pretty big topic and [again] deserves it&rsquo;s own writing. From now on I will assume that you have some familiarity with the <a href="https://docs.oracle.com/cd/E19455-01/806-5257/attrib-33670/index.html">thread stack in C</a>.</p>
<p>In AAPCS64, a stack is defined to have the following three (3) values:</p>
<ul>
<li>Base: base of the stack (e.g., <code>0x800</code>)</li>
<li>Limit: limit of the stack (e.g., <code>0x400</code>)</li>
<li>Current Extent: current tack pointer (SP) (e.g., <code>0x600</code>)</li>
</ul>
<p>The SP is basically a pointer that moves from base to limit as the stack grows. And from limit to base as the stack shrinks. Below is a visualization on this concept.</p>
<p><img src="c-stack-aapcs64.png" alt="">
An Example Program&rsquo;s Stack And AAPCS64-Related Definitions</p>
<p>AAPCS64 further defines the stack to be full-descending. Now, there are four (4) different stack organizations. I am not going to explain them here as there is a <a href="https://faculty.cs.niu.edu/~winans/CS463/notes/stack.pdf">great note about them by John Winans</a>. I highly recommend you to read at is it&rsquo;s very informative and pretty short. It shouldn&rsquo;t take more than 15 minutes to understand it.</p>
<p><img src="stack-types.gif" alt="">
Different Kinds of Stack Implementations  -  Source: <a href="https://azeria-labs.com/functions-and-the-stack-part-7/">https://azeria-labs.com/functions-and-the-stack-part-7/</a></p>
<p>Last, but not least, the AAPCS64 uses the stack to passing parameters. If there are more than eight (8) parameters, that is the <code>X0 … X7</code> is already used, then the rest is put in stack. Below is an <a href="https://godbolt.org/z/cea5j9GMd">example C function</a> and it&rsquo;s machine code that shows how stack is used to pass parameters.</p>
<p><img src="c-stack-12-params.png" alt="">
Notice How The First Eight (8) and The Last Remaining Four (4) Parameters Are Passed</p>
<h1 id="machine-registers">Machine Registers</h1>
<p>Like we have seen before, Arm 64-bit architecture defines two mandatory register banks: general-purpose and SIMD. Technically, you can use them however you want, but in practice each have their own purposes defines by AAPCS64.</p>
<p><img src="aarch64-general-purpose-simd-aio.png" alt="">
AArch64 General-Purpose &amp; SIMD Registers</p>
<p>Let&rsquo;s talk about each of those registers.</p>
<p><code>X0 … X7</code>: These register are used to store the first eight (8) parameters of a function. The caller fills these register and then the callee function can use them however it sees fit. </p>
<p>Before the function returns, the X0 must be updated by the callee to store the function return value. However, if the return type is void or not used, compilers can optimize this away.</p>
<p><img src="x0-x7-passed-returned.png" alt="">
The Function &lsquo;sum8(…)&rsquo; And It&rsquo;s Machine Code Generated By g++  - <a href="https://godbolt.org/z/9G17ocG9n"> See Both On Godbolt</a></p>
<p><code>X8</code>: Also known as indirect result register. Frankly, I don&rsquo;t think the usage of this is well defined. AAPCS64 states that &ldquo;This is used to pass the address location of an indirect result, for example, where a function returns a large structure.&rdquo; <a href="https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170&amp;viewFallbackFrom=vs-2019">From what I gather around the internet</a>, each OS (e.g., Windows) and language (e.g., C++) uses it a bit differently.</p>
<p>Basically, if an object is too big to fit into a 64-bit register (or divided into multiple ones) the caller reserves a memory region (via stack or heap). It then passes a pointer/reference of that object inside the X8 register. After that, the callee is able to access that [big] object. Below is a basic example on this.</p>
<p>Unfortunately, I couldn&rsquo;t succeed in creating an example C++ code which GCC generates a machine code utilizing the X8. However, <a href="https://godbolt.org/z/hxGedET6Y">when I tried Clang and MSVC</a>, they both utilized it as an indirect result and a scratch register.</p>
<p><img src="x8-clang.png" alt="">
Clang Compiler Utilizing The &lsquo;X8&rsquo; Register</p>
<p><code>X9 … X15</code>: These are just scratch registers. Meaning a function can use them freely as temporary storages for intermediate calculations or data. AAPCS64, however, gives them a purpose and a name: caller-saved registers.</p>
<p>These register should be used by a function for values that are NOT needed after the next function call (if exists). And if it&rsquo;s needed (and you must use them after) then the caller is the one responsible of saving them before the call. Now, when I first saw this, it all seemed so vague and confusing. Like, okay… How do I know which values are needed and which are not? Why can&rsquo;t I just use them normally?</p>
<p><img src="aarch64-caller-saved.png" alt="">
AArch64 Caller-Saved Registers: X9 … X15</p>
<p>For that I needed an example. I couldn&rsquo;t find a good one. But I did find <a href="https://stackoverflow.com/questions/9268586/what-are-callee-and-caller-saved-registers/56178078#56178078">one explanation</a> that made it all make sense. You can read it If you want, but if you can wait a little bit, I prepared an example after this section that will help you understand on why they exists and why you shouldn&rsquo;t just use them normally.</p>
<p><code>X16 - X17</code>: Ah the twin registers, also known as IP0 and IP1. They are the intra-procedure-call temporary registers. Like others, they can be as scratch registers, but AAPCS64 marks them as &ldquo;corruptible by function&rdquo;. Meaning, after ANY function call, the caller assumes them to be corrupt and act accordingly.</p>
<p><img src="aarch64-bl-instruction.png" alt="">
<a href="https://developer.arm.com/documentation/ddi0602/2024-06/Base-Instructions/BL--Branch-with-link-">ARM &lsquo;BL&rsquo; Instruction</a>  -  Notice the +/- 128MB Range Under &lsquo;Assembler Symbols&rsquo;</p>
<p>In practice, however, they are used by <a href="https://stackoverflow.com/questions/64893770/what-is-veneer-that-arm-linker-uses-in-function-call">veneers</a> and other similar pieces of code. In <a href="https://developer.arm.com/documentation/ddi0596/latest/">Arm A64 ISA</a>, the <a href="https://developer.arm.com/documentation/dui0802/b/A64-General-Instructions/BL"><code>BL</code></a> branch line instruction can only in the range of PC +/-128MiB. Most of the time your code won&rsquo;t have to jump around that much, but sometimes it happens (e.g., dynamic libraries OR switching from lower-address to higher-address range in kernel syscalls).</p>
<p>To overcome this range limitation, compilers (like GCC) uses a small piece of code called veneers. I don&rsquo;t really looked at how they work, but know that they used to jump between codes that are FURTHER away from each other in [virtual] memory. Hence the IP0 and IP1 are called the intra-procedure-call registers.</p>
<p><img src="veneer-detailed.png" alt="">
Veneer Code Generated by GCC For The &lsquo;kmain()&rsquo; Function Located at 0xFFFF00004011AA60</p>
<p><code>X18</code>: It&rsquo;s called the platform register. Like the name suggests, each platform (e.g., Linux, Windows, macOS) can define whatever use for it they want. The exact usage of it can also change from platform version to version.</p>
<ul>
<li><a href="https://developer.apple.com/documentation/xcode/test-coverage">Apple</a> (macOS, iOS, iPadOS…): <a href="https://opensource.apple.com/source/xnu/xnu-7195.141.2/tests/x18.c.auto.html">Reserved</a></li>
<li><a href="https://patchwork.kernel.org/project/linux-hardening/patch/20170712144424.19528-8-ard.biesheuvel@linaro.org/">Linux</a>: <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched/task.h">Task Structure</a> pointer in kernel mode; (?) in user mode</li>
<li><a href="https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170">Windows</a>: <a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Environment Block</a> pointer in user mode; reserved in kernel mode</li>
</ul>
<p><img src="apple-xnu-x18.png" alt="">
Apple&rsquo;s XNU Code That Checks For X18&rsquo;s Preservation</p>
<p>As you can see, it isn&rsquo;t much used or have a well-defined usage on some common platforms. It&rsquo;s recommended (at least for now) just avoid using it.</p>
<p><code>X19 .. X28</code>: Just like the previous scratch registers (caller-saved ones), these registers are also scratch registers. Similarly, AAPCS64 gives them their own purpose and name: callee-saved registers.</p>
<p>These register should be by the function if they ARE needed to be preserved after the call. The callee is the one responsible of saving AND restoring them.</p>
<p><img src="aarch64-callee-saved.png" alt="">
AArch64 Calle-Saved Registers: X19 … X28</p>
<p>Just like the caller-saved registers, the explanation by Arm and AAPCS64 seems confusing. In the coming section I will give a concrete example that will help you understand what it&rsquo;s meant by callee &amp; caller saved registers.</p>
<p><code>X29</code>: This is the register that holds the frame pointer as describe by AAPCS64. A frame pointer is.. well a pointer that is used to keep track of the <a href="https://en.wikipedia.org/wiki/Call_stack#Stack_and_frame_pointers">stack frame</a>. When a new stack frame is created (after a function call) the base address of it is stored inside this register.</p>
<p><img src="x29-frame-pointer.png" alt="">
X29 (Frame Pointer) Before And After The Call To &lsquo;FunctionB()&rsquo;</p>
<p>In practice, compilers can generate machine code that makes use of this register to store the frame pointer and then use it to locate certain variables/object that resides within the stack. They can technically just use the <code>SP</code> stack pointer, but that pointer is dynamic! It moves during the runtime so it&rsquo;s harder (maybe impossible?) to use it to access local variables. Frame pointers, however, are static and do not change during a function&rsquo;s lifetime. So, they can be easily used to calculate variable locations.</p>
<p><code>X30</code>: Last, but not least, the link register! Have you ever wondered when a function is called how does it know where to return after? Well, the link register is how.</p>
<p>Before a thread executes the <code>BL</code> branch with link instruction (basically calling a function) the link register is set to the current <code>PC</code> program counter so that when the function returns with <code>RET</code> this register would be pointing to the caller function. The exact value hold in it is the address of the NEXT instruction right after <code>BL</code>.</p>
<p><img src="x30-link-register.png" alt="">
X30 Updated To The Next Instruction (PC + 12) That is Right After main.cpp:14</p>
<p>As you can see from the image X30 was updated to hold the next instruction (machine code, not source line) right after the call to multiply(). The value is of course pre-calculated (before BL) via the PC register. So, in the example above, the X30 becomes PC + 12. The number here, 12, can be calculated by looking at the machine code. I didn&rsquo;t give that code to keep things simple. But, you can easily check it out yourself by creating the example above.</p>
<p>Now we have one more thing to talk about. Notice that the link register only holds the previous function&rsquo;s address. But, what if we call multiple functions? Where would their return addresses be stored? Again, thee answer is: by using the stack.</p>
<p><a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#subroutine-calls">AAPCS64 further details</a> that before calling a function and modifying the link register, its current value should be pushed to the stack. And then, when the called function returns, the value is popped and written back to the link register. Therefore, preserving the order of function calls!</p>
<blockquote>
<p>One last thing I want to talk shortly about is SIMD registers. <a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#simd-and-floating-point-registers">AAPCS64 also talks about them</a>, but not in great detail compared to general-purpose ones as their purpose is pretty straightforward.
<br>
<br>
SIMD registers are named <code>V0 … V31</code>. The first eight (8) register <code>V0 … V7</code> are used to pass parameters and to return the result value from a function. Registers <code>V8 … V17</code> are callee-preserved registers that have seen before. The rest can be used as a scratch register like normal.</p>
</blockquote>
<h1 id="iv-caller-saved--callee-saved">IV. Caller-Saved &amp; Callee-Saved</h1>
<p>When I first saw these terms, I was confused. Why would someone categorize the scratch registers into caller &amp; callee saved? Why shouldn&rsquo;t I just use them however I want? Technically, yes, you can use them freely. But, there are two things  you need to be aware of: optimization and modularity.</p>
<p>Remember the following:</p>
<ul>
<li><code>X0 … X7</code>: Used to pass the first eight (8) parameters</li>
<li><code>X9 … X15</code>: Caller-saved registers</li>
<li><code>X19 … X28</code>: Callee-saved registers</li>
</ul>
<p>Let&rsquo;s talk about an example C++ code. Don&rsquo;t worry about the naming and such; I created it just to show how registers are used within GCC.</p>
<div class="highlight"><pre tabindex="0" style="color:#4d4d4d;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#5918bb;font-weight:bold">uint64_t</span> <span style="color:#ff8000;font-weight:bold">loop</span>(<span style="color:#5918bb;font-weight:bold">uint64_t</span> a, <span style="color:#5918bb;font-weight:bold">uint64_t</span> b, <span style="color:#5918bb;font-weight:bold">uint64_t</span> c, <span style="color:#5918bb;font-weight:bold">uint64_t</span> d, <span style="color:#5918bb;font-weight:bold">uint64_t</span> e, <span style="color:#5918bb;font-weight:bold">uint64_t</span> f, <span style="color:#5918bb;font-weight:bold">uint64_t</span> g, <span style="color:#5918bb;font-weight:bold">uint64_t</span> h) {
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> result <span style="color:#2c5dcd">=</span> <span style="color:#5918bb;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">for</span> (<span style="color:#5918bb;font-weight:bold">int</span> i <span style="color:#2c5dcd">=</span> <span style="color:#5918bb;font-weight:bold">0</span>; i <span style="color:#2c5dcd">&lt;</span> <span style="color:#5918bb;font-weight:bold">16</span>; <span style="color:#2c5dcd">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#0080ff;font-style:italic">// Random calculations on the function parameters
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>        a <span style="color:#2c5dcd">+=</span> b <span style="color:#2c5dcd">+</span> c <span style="color:#2c5dcd">*</span> d;
</span></span><span style="display:flex;"><span>        b <span style="color:#2c5dcd">^=</span> e <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>        c <span style="color:#2c5dcd">*=</span> f <span style="color:#2c5dcd">+</span> g;
</span></span><span style="display:flex;"><span>        d <span style="color:#2c5dcd">-=</span> h <span style="color:#2c5dcd">*</span> a;
</span></span><span style="display:flex;"><span>        e <span style="color:#2c5dcd">+=</span> f <span style="color:#2c5dcd">^</span> g;
</span></span><span style="display:flex;"><span>        f <span style="color:#2c5dcd">=</span> (g <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">3</span>) <span style="color:#2c5dcd">-</span> d;
</span></span><span style="display:flex;"><span>        g <span style="color:#2c5dcd">+=</span> h <span style="color:#2c5dcd">*</span> e;
</span></span><span style="display:flex;"><span>        h <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">|</span> b <span style="color:#2c5dcd">|</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0080ff;font-style:italic">// Call another function
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>        result <span style="color:#2c5dcd">+=</span> <span style="color:#ff8000;font-weight:bold">calc</span>(a, b, c, d, e, f, g, h);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>All it does is just do some calculations on eight (8) different variables, with each being taken as a parameter. After that, they are all passed to another function that does even more calculation. Let&rsquo;s see it.</p>
<div class="highlight"><pre tabindex="0" style="color:#4d4d4d;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#5918bb;font-weight:bold">uint64_t</span> <span style="color:#ff8000;font-weight:bold">calc</span>(<span style="color:#5918bb;font-weight:bold">uint64_t</span> a, <span style="color:#5918bb;font-weight:bold">uint64_t</span> b, <span style="color:#5918bb;font-weight:bold">uint64_t</span> c, <span style="color:#5918bb;font-weight:bold">uint64_t</span> d, <span style="color:#5918bb;font-weight:bold">uint64_t</span> e, <span style="color:#5918bb;font-weight:bold">uint64_t</span> f, <span style="color:#5918bb;font-weight:bold">uint64_t</span> g, <span style="color:#5918bb;font-weight:bold">uint64_t</span> h) {
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> a1 <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, b1 <span style="color:#2c5dcd">=</span> b <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, c1 <span style="color:#2c5dcd">=</span> c <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, d1 <span style="color:#2c5dcd">=</span> d <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> e1 <span style="color:#2c5dcd">=</span>  e<span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, f1 <span style="color:#2c5dcd">=</span> f <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, g1 <span style="color:#2c5dcd">=</span> g <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>, h1 <span style="color:#2c5dcd">=</span> h <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">42</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// More local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> i <span style="color:#2c5dcd">=</span> a <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">10</span>, j <span style="color:#2c5dcd">=</span> b <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">20</span>, k <span style="color:#2c5dcd">=</span> c <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">30</span>, l <span style="color:#2c5dcd">=</span> d <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">40</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> m <span style="color:#2c5dcd">=</span> e <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">50</span>, n <span style="color:#2c5dcd">=</span> f <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">60</span>, o <span style="color:#2c5dcd">=</span> g <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">70</span>, p <span style="color:#2c5dcd">=</span> h <span style="color:#2c5dcd">+</span> <span style="color:#5918bb;font-weight:bold">80</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Random calculations on the local variables
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    a1 <span style="color:#2c5dcd">+=</span> b1 <span style="color:#2c5dcd">-</span> c1 <span style="color:#2c5dcd">*</span> d1;
</span></span><span style="display:flex;"><span>    b1 <span style="color:#2c5dcd">^=</span> e1 <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    c1 <span style="color:#2c5dcd">*=</span> f1 <span style="color:#2c5dcd">-</span> g1;
</span></span><span style="display:flex;"><span>    d1 <span style="color:#2c5dcd">+=</span> h1 <span style="color:#2c5dcd">/</span> a1;
</span></span><span style="display:flex;"><span>    e1 <span style="color:#2c5dcd">+=</span> f1 <span style="color:#2c5dcd">^</span> g1;
</span></span><span style="display:flex;"><span>    f1 <span style="color:#2c5dcd">=</span> (g1 <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">2</span>) <span style="color:#2c5dcd">+</span> d1;
</span></span><span style="display:flex;"><span>    g1 <span style="color:#2c5dcd">-=</span> h1 <span style="color:#2c5dcd">*</span> e1;
</span></span><span style="display:flex;"><span>    h1 <span style="color:#2c5dcd">=</span> a1 <span style="color:#2c5dcd">&amp;</span> b1 <span style="color:#2c5dcd">&amp;</span> c1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i <span style="color:#2c5dcd">+=</span> j <span style="color:#2c5dcd">*</span> k <span style="color:#2c5dcd">-</span> l;
</span></span><span style="display:flex;"><span>    j <span style="color:#2c5dcd">^=</span> m <span style="color:#2c5dcd">&gt;&gt;</span> <span style="color:#5918bb;font-weight:bold">3</span>;
</span></span><span style="display:flex;"><span>    k <span style="color:#2c5dcd">*=</span> n <span style="color:#2c5dcd">+</span> o;
</span></span><span style="display:flex;"><span>    l <span style="color:#2c5dcd">-=</span> p <span style="color:#2c5dcd">*</span> i;
</span></span><span style="display:flex;"><span>    m <span style="color:#2c5dcd">+=</span> n <span style="color:#2c5dcd">^</span> o;
</span></span><span style="display:flex;"><span>    n <span style="color:#2c5dcd">=</span> (o <span style="color:#2c5dcd">&lt;&lt;</span> <span style="color:#5918bb;font-weight:bold">2</span>) <span style="color:#2c5dcd">-</span> l;
</span></span><span style="display:flex;"><span>    o <span style="color:#2c5dcd">+=</span> p <span style="color:#2c5dcd">*</span> m;
</span></span><span style="display:flex;"><span>    p <span style="color:#2c5dcd">=</span> i <span style="color:#2c5dcd">|</span> j <span style="color:#2c5dcd">|</span> k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0080ff;font-style:italic">// Return the result [X0]
</span></span></span><span style="display:flex;"><span><span style="color:#0080ff;font-style:italic"></span>    <span style="color:#5918bb;font-weight:bold">uint64_t</span> result <span style="color:#2c5dcd">=</span> a1 <span style="color:#2c5dcd">+</span> b1 <span style="color:#2c5dcd">+</span> c1 <span style="color:#2c5dcd">+</span> d1 <span style="color:#2c5dcd">+</span> e1 <span style="color:#2c5dcd">+</span> f1 <span style="color:#2c5dcd">+</span> g1 <span style="color:#2c5dcd">+</span> h1 <span style="color:#2c5dcd">+</span> i <span style="color:#2c5dcd">+</span> j <span style="color:#2c5dcd">+</span> k <span style="color:#2c5dcd">+</span> l <span style="color:#2c5dcd">+</span> m <span style="color:#2c5dcd">+</span> n <span style="color:#2c5dcd">+</span> o <span style="color:#2c5dcd">+</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2c5dcd;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Basically <code>calc(...)</code> is just more calculation. But this time the amount of variables incresed. It now has sixteen (16) local variables with each being used to calculate the final result (<code>X0</code>).</p>
<p>Our problem is this: <em>Generate a good &amp; efficient machine code that utilizes register usage instead of accessing the memory using the AAPCS64.</em></p>
<p><strong>Option 1) Use stack to save those registers:</strong></p>
<p>This is the naive way of doing this. The code becomes simpler, yes. But you would be accessing the memory way more often. All those sweet scratch registers are sitting empty;( Meaning, you are missing out on optimization!</p>
<p>Here&rsquo;s the <code>ARM64 gcc 13.2.0</code> compiler with no optimization. Also, see the full code on godbolt.org: <a href="https://godbolt.org/z/T9GKG96Tz">https://godbolt.org/z/T9GKG96Tz</a></p>
<p><img src="godbolt-option-1.png" alt="">
There Are MANY Stack (Memory) Accesses Within &lsquo;calc()&rsquo;  -  It Works, But Not Efficiently</p>
<p><strong>Option 2) Use the scratch registers:</strong></p>
<p>Now the fun begins by thinking smart. We have the following 25 register at our disposal: <code>X0 … X7</code>, <code>X9 … X15</code> and <code>X19 … X28</code>. We could just save each variable to an empty register. But what if someone were using that (e.g., previous function)? We can&rsquo;t just assume they are free to use, otherwise we risk corrupting the whole program.</p>
<p>What we can do is push ALL the registers onto the stack and freely use the registers. After we are done, we could just pop them out. Alright… we are getting somewhere. However, still we are accessing the stack, still we are accessing the memory! There must be a smarter way of doing this.</p>
<p>It seems we need a way to tell which registers are free to use. So that can avoid pushing ALL register to stack vs. SOME registers. And guess what? AAPCS64 explicitly talks about this!</p>
<p><img src="aarch64-callee-and-caller-saved.png" alt="">
Although AAPCS64 Gives Them A Purpose (<a href="https://eldenring.wiki.fextralife.com/Melina#:~:text=My%20children%20beloved.%20Make%20of%20thyselves%20that%20which%20ye%20desire.">Like Marika</a>) It Is The Decision of The Compiler To Make Use</p>
<p>Here, we are introduced to caller-saved and callee-saved registers. I&rsquo;m not going to repeat what&rsquo;s written in AAPCS64. Instead, I will give you the intuition. </p>
<h1 id="caller-saved-registers-x9-x15">Caller-saved registers (<code>X9 … X15</code>)</h1>
<p>If you DO NOT care about what happens to a temporary value after a function call, then use these registers. They are also called volatile registers for this exact reason. The values MIGHT be changed by the function, so DO NOT use them to store values you want to keep after a function call.</p>
<ul>
<li>From the caller&rsquo;s perspective: Assume registers are to be destroyed </li>
<li>From the callee&rsquo;s perspective: Freely use the registers</li>
</ul>
<blockquote>
<p>You might wonder, then why they are named caller-saved? Frankly, idk. The caller COULD save them to stack if it wants, but does NOT have to. So, I (<a href="https://stackoverflow.com/questions/9268586/what-are-callee-and-caller-saved-registers/56178078#56178078">and many others</a>) think the name is misleading.</p>
</blockquote>
<h1 id="callee-saved-registers-x19-x28">Callee-saved registers (<code>X19 … X28</code>)</h1>
<p>If you DO care about the retaining a temporary value after a function call, then use these registers. They are also called non-volatile registers for this exact reason. Assume that the values are to be RETAINED and you must save them to the stack before doing anything to them. Interesting thing her is it is NOT the caller, but the callee that should save them. As to why? I don&rsquo;t know.</p>
<ul>
<li>From the caller&rsquo;s perspective: Do nothing. They won&rsquo;t be changed</li>
<li>From the callee&rsquo;s perspective: Save them to stack &amp; then restore after</li>
</ul>
<p><img src="caller-vs-callee.png" alt="">
Comparing Caller &amp; Callee - Saved Registers</p>
<p>Now, we have enough information on our hand about the scratch registers. We can use this to optimize our code. As to how? I don&rsquo;t really know. This is an area where compiler engineers work to optimize. Each different compiler and their version will use these registers differently.</p>
<p>Let&rsquo;s look at the code generated by <code>ARM64 gcc 13.2.0</code> with the <code>-O1</code> optimization flag. Also, see the full code on godbolt.org: <a href="https://godbolt.org/z/ETc81YadG">https://godbolt.org/z/ETc81YadG</a></p>
<p><img src="godbolt-option-2.png" alt="">
Most (if not all) Calculations Are Done Using The Scratch Registers - Efficient!</p>
<p>Notice how BOTH the caller-saved and callee-saved registers are used. Again, how compilers decide on which to use depends on its design &amp; goals.</p>
<h1 id="closing-words">Closing Words</h1>
<p>And with all that, we know have a little bit more information about AAPCS64 and how calling conventions work. There is a lot to unpack here. Don&rsquo;t feel bad if you don&rsquo;t understand each and everything. Just keep reading, practicing and learning. I highly encourage you to come to this writing again after a couple of weeks. After some time, your brain would be done processing everything. By reading this again, everything then would make a lot more sense. And who knows, maybe you would learn A NEW thing you missed during the first time.</p>
<p>I want to point out that lot&rsquo;s of details were left out to keep things simple &amp; straightforward. AAPCS64 is a long document with many technical details. For the purpose of this writing I didn&rsquo;t talk about them. Keeping everything on ELI5 level was my goal.</p>
<p>By cutting and compressing everything from the AAPCS64, I might&rsquo;ve made some mistakes. If you think there is one, feel free to contact me. I wouldn&rsquo;t want to give wrong information.</p>
<p>And lastly, thanks for reading.</p>
<p>Enjoy Life ❤</p>

    </div>
	<div class="post-footer">
		<hr />

		<img src="/blog/signature.png" alt="signature" style="height: 55px;" />

		<p>Thanks for reading & Take care <span style="font-style: normal;"> ❤ </span></p>
		<p>
			Follow me on
			<a href="https://twitter.com/tunacicii">X (formerly Twitter)</a>,
      if you like my works that is >.&lt;
		</p>

	</div>
  </article>

  <hr />

  <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/memes/">Memes</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <nav id="TableOfContents"></nav>
    </div>

    <div id="share-footer" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f">
      <i class="fab fa-facebook fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&text=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-twitter fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-linkedin fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&is_video=false&description=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-pinterest fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers&body=Check out this article: https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f">
      <i class="fas fa-envelope fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-reddit fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&title=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-digg fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&name=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers&description=Programming%20using%20high-level%20languages%20makes%20a%20ton%20of%20stuff%20trivial.%20Your%20compiler%2finterpreter%20abstracting%20lots%20stuff%20from%20you%20so%20that%20you%20can%20focus%20on%20what%26rsquo%3bs%20important%3a%20getting%20shit%20done%2c%20efficiently.%20One%20of%20those%20abstractions%20is%20functions.%0aCalling%20a%20function%20is%20one%20of%20the%20first%20things%20you%20learn%20when%20starting%20programming.%20They%20are%20relatively%20trivial%3a%20you%20just%20type%20the%20function%20name%2c%20pass%20some%20parameters%20and%20then%20it%20does%20what%20it%26rsquo%3bs%20meant%20to%20do%20%28or%20not%29.">
      <i class="fab fa-tumblr fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2ftunacici.com%2fblog%2f2024%2f07%2faarch64-procedure-call-standard-aapcs64-abi-calling-conventions-machine-registers%2f&t=AArch64%20Procedure%20Call%20Standard%20%28AAPCS64%29%3a%20ABI%2c%20Calling%20Conventions%20%26%20Machine%20Registers">
      <i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>

    <div id="actions-footer">
      
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;">
          <i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;">
          <i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;">
          <i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
          <i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>


  <footer id="footer">
  <div class="footer-left">
    Pasteleft &#9752; 2024  Tuna Cici (Blog) 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/blog/">Home</a></li>
         
        <li><a href="/blog/memes/">Memes</a></li>
         
        <li><a href="/blog/about/">About</a></li>
         
        <li><a href="/blog/contact/">Contact</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/blog/lib/font-awesome/css/all.min.css>
<script src=/blog/lib/jquery/jquery.min.js></script>
<script src=/blog/js/main.js></script>



</html>
